*
*-- NJE38 - TSO RECEIVE
*
*   Command line format (all parameters are optional):
*
*   RECEIVE  filenum
*            DATASET( )
*            VOLSER( )
*            UNIT( )
*            DIR( )
*            INDATASET( )
*            PURGE  | NOPURGE
*            PROMPT | NOPROMPT
*            QUIET
*
*   where:
*
*    filenum        - specifies a specific NJE38 spool file number
*                     to be received.  If not specified, the next
*                     available spool file is received.  Ignored if
*                     INDATASET is specified.
*
*    DATASET( )     - specifies the dsname of the dataset to be
*                     created; the received data will be placed within.
*                     If not specified, the dataset name will be
*                     derived from the incoming dataset name, with
*                     the first qualifer being replaced by the
*                     receiver's TSO userid.
*
*    VOLSER( )      - specifies a volume where DATASET should be
*                     created.  If not specified, a PUBLIC volume will
*                     be chosen based on the receiving dataset's
*                     attributes.
*
*    UNIT( )        - specifies a unit name where DATASET should be
*                     created.  If not specified, SYSDA is the default
*                     unit name.
*
*    DIR( )         - specifies a number of directory blocks if
*                     incoming file was a PDSE.
*
*    INDATASET( )  -  optional. Specifies that the encoded named
*                     dataset is to be received.  The encoded dataset
*                     was previously created by TRANSMIT using
*                     OUTDATASET.  May optionally specify a membername.
*
*    PURGE          - DEFAULT.  Indicates that RECEIVE is to purge
*                     the spool file after successful retrieval. Has
*                     no meaning if INDATASET is specified.
*
*    NOPURGE        - Indicates that RECEIVE is to retain the spool
*                     file.  The file can be received again or must be
*                     removed from the spool by other means.  Has
*                     no meaning if INDATASET is specified.
*
*    PROMPT         - DEFAULT.  Indicates that RECEIVE is to prompt
*                     the TSO user to respecify DATASET or VOLSER
*                     after learning the incoming dataset name. The
*                     user can then choose to change the name or
*                     volume.
*
*    NOPROMPT       - Indicates that no prompts are to be issued.  If
*                     errors are encountered, such as the incoming
*                     dataset name already existing, then RECEIVE is
*                     terminated without any opportunity to change
*                     the parameters.
*
*    QUIET          - If specified, indicates that all informational
*                     messages from  RECEIVE are suppressed.  Error
*                     messages will always be displayed. QUIET also
*                     forces on NOPROMPT.
*
*
* Change log:
*
*
* 21 Oct 21 - Temp dataset on IEBCOPY type receive not using vol   v230
*              identified by GETVOL (instead uses hi-cuu PUBLIC)   v230
* 22 Jul 21 - Typo could cause alloc error with user coded volume  v230
* 24 Apr 21 - Use TSO userid as default user if no security and    v222
*              NJE38 is not active.                                v222
* 15 Feb 21 - Not picking up jobname when run as an STC.           v221
* 01 Oct 20 - Put ENQ existence check in common module             v210
* 09 Aug 20 - Improve TSO attention key handling                   v201
* 13 Jul 20 - Flat file with JCL sneaks by NETDATA checks, causing v200
*             loss of first record in result.                      v200
* 12 Jul 20 - Add support for DIR( ) command line parameter        v200
* 10 Jul 20 - Add support for UNIT( ) command line parameter       v200
* 08 Jul 20 - IEBCOPY failures if netdata records shorter than 80  v200
* 15 May 20 - Initial creation
*
*
         GBLC  &VERS
         REGEQU
NJERCV   CSECT                                                          NJE00020
         NJEVER
         STM   R14,R12,12(R13)         Save Regs                        NJE00050
         LR    R12,R15                 Base                             NJE00060
         USING NJERCV,R12                                               NJE00070
         LR    R8,R1                   Copy input parm addr
*
         GETMAIN RU,                   Get local stg area              X
               LV=4096,                                                X
               BNDRY=PAGE
         LR    R10,R1
         LR    R1,R0                   Copy length
         LR    R2,R0                   Copy length
         LR    R0,R10                  -> new stg area
         SR    R15,R15                 set pad
         MVCL  R0,R14                  Clear the page
*
         USING NJEWK,R10
         ST    R13,NJESA+4             SAVE prv S.A. ADDR               NJE00080
         LA    R1,NJESA                -> my save area
         ST    R1,8(,R13)              Plug it into prior SA
         LR    R13,R1
*
         MVC   NJEEYE,=CL4'NJER'       Work area eyecatcher
         ST    R2,NJEWKLEN             Save size of area in area
         L     R11,=A(NJECOM)          -> common csect
         USING NJECOM,R11
         ST    R8,CPARMS               Save ptr to input parms
         MVC   OLD,=F'1'               Set number of PUTGET segments
         OI    FLAGS3,F3PURGE          Set default: PURGE
*
INIT000  EQU   *
         MVC   MACLIST(ESTAEL),ESTAE   Move ESTAE parm list
         L     R6,=A(NJEDMP)           Point to local ESTAE rtn
         ESTAE (R6),                   Issue ESTAE                     X
               CT,                                                     X
               TERM=YES,                                               X
               PARAM=(R10),            PARAM is work area address      X
               MF=(E,MACLIST)
*
*-- Establish TSO userid issuing this command
*
         TESTAUTH FCTN=1               Are we authorized on entry?
         LTR   R15,R15                 Check result
         BNZ   INIT010                 Branch if not authorized
         OI    FLAGS1,F1APF            Indicate authorized on entry
*
INIT010  EQU   *
         L     R2,PSATOLD-PSA(0)       -> my TCB
         L     R2,TCBTIO-TCB(R2)       -> my TIOT
         LA    R4,TIOCNJOB-IEFTIOT(R2) -> TIOT jobname             v221
         LR    R3,R4                   Assume will use jobname     v222
*
         L     R2,PSAAOLD-PSA(0)       -> my ASCB
         L     R6,ASCBTSB-ASCB(,R2)    -> TSB (or 0)
         L     R2,ASCBASXB-ASCB(,R2)   -> my ASXB
         ICM   R2,15,ASXBSENV-ASXB(R2) -> my ACEE
         BZ    INIT015                 Exit if no ACEE
*
         USING ACEE,R2
         CLI   ACEEUSRL,X'00'          No userid available?
         BE    INIT015                 Exit if unavail
         CLI   ACEEUSR,X'00'           Userid not formed correctly?
         BE    INIT015                 Exit if unavail
         LA    R3,ACEEUSR              -> Userid
         OI    FLAGS1,F1ACEE           Valid ACEE found
         CLC   ACEEUSR,=CL8'STC'       Is this a started task?     v221
         BNE   INIT015                 No, use ACEEUSR id          v221
         LR    R3,R4                   Make the TIOT jobname the idv221
         DROP  R2                      ACEE
*
INIT015  EQU   *
         MVC   USERID,0(R3)            Set the userid
         TM    FLAGS1,F1APF            Authorized at entry?
         BO    INIT040                 yes.
         CLC   USERID,=CL8'HERC01'     Special access id?
         BE    INIT020                 Yes
         CLC   USERID,=CL8'HERC02'     Special access id?
         BNE   INIT030                 No
*
INIT020  EQU   *
         OI    FLAGS1,F1AUSR           Indicate special authorized user
         SR    0,0                     Use authorization SVC
         LA    1,1                      For TK4- HERC01/HERC02 only
         SVC   244                     Get authorized
         B     INIT040
*
INIT030  EQU   *
         TM    FLAGS1,F1APF            Authorized at entry?
         BZ    ERR006                  No, issue error
*
INIT040  EQU   *
         LA    R6,0(,R6)               Clear high order byte
         LTR   R6,R6                   Was there a TSB address
         BNZ   INIT045                 There was. Running in TSO userid
         OI    FLAGS1,F1BATCH          Indicate batch TSO
         TM    FLAGS1,F1ACEE           Valid ACEE found?
         BO    INIT045                 Yes, go with ACEE userid
         BAL   R2,CHK000               See if NJE38 is active      v210
         BNZ   INIT045                 NJE38 not active; use jobnamv222
         MVC   USERID,DEFUSER          Use default userid
*
INIT045  EQU   *
         L     R2,4(,R8)               -> UPT from input parms
         USING UPT,R2
         MVC   PREFIX,BLANKS           Init receiving field
         SR    R1,R1                   Clear for IC
         ICM   R1,1,UPTPREFL           Get prefix length
         BZ    INIT050                 No prefix value in use
         BCT   R1,*+10                 Adjust for execute
         MVC   PREFIX(0),UPTPREFX      executed instr
         EX    R1,*-6                  Copy the prefix value
         DROP  R2                      UPT
*
INIT050  EQU   *
         MVC   STAXLIST(STAXL),STAX    Move STAX parm list
         LA    R5,LIST                 -> input buffer from attn
         LA    R6,STAXXIT              Point to local exit
         STAX  (R6),                   Set exit for attention          X
               OBUF=(ATTNMSG,L'ATTNMSG),                               x
               IBUF=((5),80),                                          x
               USADDR=(10),            Parameter is our work area      x
               MF=(E,MACLIST)
*
*-- Parse command line
*
         SR    R0,R0                   Code 0: parse command line
         L     R15,=A(NJEPAR)          -> parse routine
         BALR  R14,R15
*
         TM    FLAGS4,F4ATTN           Was ATTN pressed?           v201
         BO    EXIT08                  Y, immediate exit           v201
         LTR   R15,R15                 Any errors?
         BNZ   ERR001                  Display IJKPARS RC
*
*-- Issue hello msgs
*
INIT060  EQU   *
         LA    R2,MSG000               Issue hello msg
         BAL   R14,PUTLINE
         LA    R2,MSGBLNK              Issue blank line
         BAL   R14,PUTLINE
*
*-- Are we reading from the NJE38 spool or an INDATASET?
*
         TM    FLAGS3,F3INDS           INDATASET specified?
         BZ    OPN000                  No, use NETSPOOL
*
*-- Set up INDATASET
*
INIT080  EQU   *
         MVC   TDSNAME,USRINDS         Set DSNAME of INDATASET
*
         LA    R0,DYNINDS         24   allocate INDATASET
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15                 Any errors?
         BNZ   EXIT08                  Exit if allocation error
*
         MVC   NETDATA(DMYNPOL),DMYNPO Set up DCB for PDS
         CLI   TDSORG,X'02'            Was DSORG=PO ?
         BE    *+10                    Yes
         MVC   NETDATA(DMYNPSL),DMYNPS Set up DCB for SEQL
*
         MVC   DDNETDAT,TDDNAME        Save off the DDNAME returned
         MVC   DECB(READL),READ        Set up DECB
         LA    R6,NETDATA              -> DCB
         USING IHADCB,R6
         MVC   DCBDDNAM,DDNETDAT       Set DCB DDNAME
*
         MVC   MACLIST(OPENL),OPEN     Move OPEN list
         OPEN  (NETDATA,INPUT),        Open the NETDATA dataset        X
               MF=(E,MACLIST)
         OI    FLAGS2,F2NETOPN         Indicate DCB is open
*
         CLC   DCBLRECL,=Y(80)         Is LRECL 80?
         BNE   ERR009                  No, cant be netdata file
         TM    DCBRECFM,DCBRECF        Fixed length records?
         BZ    ERR009                  No, cant be netdata file
*
         LH    R0,DCBBLKSI             Get physical blksize
         ST    R0,BLOCKLEN             Save it
         GETMAIN RU,LV=(0)             Get buffer to read blocks
         ST    R1,BLOCK                Save buffer addr
         DROP  R6
*
         CLI   TDSORG,X'40'            Was DSORG=PS ?
         BE    INIT100                 Yes, don't do the FIND
*
         FIND  NETDATA,USRMEM,D        Point to the member
         LTR   R15,R15                 Any errors?
         BNZ   ERR004                  Exit if member not found
*
*-- Process the initial NETDATA control records from INDATASET
*
INIT100  EQU   *
         SR    R0,R0                   Code 0, process initial NETDATA
         L     R15,=A(NJENET)          -> NETDATA parsing routines
         BALR  R14,R15                 Process the control records
*
         B     INIT110(R15)            Branch based on error
INIT110  B     USR000              00  Normal, proceed.
         B     ERR008              04  File is not NETDATA
         B     EXIT08              08  Invalid NETDATA encountered
         B     ERR005              0C  Unexpected EOF on INDATASET
         B     ERR007              10  READ i/o error on INDATASET
         B     ERR030              14  INMTEXT detected, not supported
         B     ERR038              18  Record segments exceed LRECLv222
*
*-- Open NETSPOOL
*
OPN000   EQU   *
         BAL   R2,CHK000               Get NJE38 Spool DSN         v210
         BNZ   ERR013                  NJE38 is not active         v210
*
         MVC   DDNETSPL,=CL8'NETSPOOL' Set NETSPOOL DDN (for unalloc)
         MVC   TDDNAME,DDNETSPL        NETSPOOL DD
         LA    R0,DYNETSPL        28   allocate NETSPOOL
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXIT08                  Exit with dynalloc error
*
         LA    R8,NCB1                 -> NCB
         USING NCB,R8
*
         LA    R6,TAGDATA              -> area to hold tag data
         USING TAG,R6
*
         NSIO  TYPE=OPEN,                                              x
               NCB=(R8),                                               x
               TAG=(R6),               -> Where tag data will be       x
               EODAD=EOD000
         C     R15,=F'4'               NETSPOOL needs verify?
         BE    ERR025                  Yes
         BL    OPN010                  Everything is good
         BAL   R14,FMT000              Display Open error
         CLC   NCBRTNCD(2),=AL1(8,152) X'0898' security denied access?
         BE    ERR032                  Yes, special msg
         B     EXIT08                  Exit on VSAM error
*
OPN010   EQU   *
         OI    FLAGS2,F2NCBOPN         Indicate NETSPOOL is open
         TM    FLAGS3,F3FILEID         Specific file # specified?
         BO    OPN020                  Yes
*
*-- Here for 'next' available spool file
*
         NSIO  TYPE=CONTENTS,          Get list of files               x
               NCB=(R8)
         LTR   R15,R15                 Any errors?
         BZ    OPN030                  No
         CLC   NCBRTNCD(2),=AL1(12,6)  No files in directory?
         BE    ERR010                  Close up and indicate no files
         BAL   R14,FMT000              Display error
         B     EXIT08                  Exit on VSAM error
*
*-- Here for 'specific' spool file number
*
OPN020   EQU   *
         MVC   TAGID,FILEID+2          Set file # to find
*
         NSIO  TYPE=FIND,              get directory entry             x
               NCB=(R8),                                               x
               TAG=(R6)                Where to place tag data
         LTR   R15,R15                 Any errors?
         BZ    OPN200                  No, process file
         CLC   NCBRTNCD(2),=AL1(12,4)  Was file id not found?
         BE    ERR011                  Yes
         BAL   R14,FMT000              Otherwise, display error
         B     EXIT08                  Exit on VSAM error
*
*-- Look for next available in contents directory
*
OPN030   EQU   *
         L     R2,NCBAREA              Get a list of spool content
         USING NSDIR,R2
         SR    R5,R5
         ICM   R5,3,NCBRECCT           # of returned entries
         SR    R6,R6                   Indicate nothing found yet
*
OPN040   EQU   *
         CLC   LCLNODE,NSTOLOC         Is this file for this link?
         BNE   OPN160                  no, skip this file
         TM    FLAGS1,F1ACEE           Was security available?
         BZ    OPN150                  No; do not enforce selection
         CLC   USERID,NSTOVM           Is this file for this userid?
         BNE   OPN160                  no, skip this file
*
OPN150   EQU   *
         LA    R6,TAGDATA              -> tag data area for file
         USING TAG,R6
         XC    TAGDATA(TAGLEN),TAGDATA
         MVC   TAGINLOC(TAGUSELN),NSINLOC  Copy tag datq
         B     OPN170                  Go process the file
*
OPN160   EQU   *
         LA    R2,NSDIRLN(,R2)         Next NETSPOOL dir entry
         BCT   R5,OPN040               Continue thru the contents
         DROP  R2                      NSDIR
*
*
OPN170   EQU   *
         LM    R0,R1,NCBAREAL          Get list length and address
         XC    NCBAREA,NCBAREA         Clear obsolete ptr
         FREEMAIN RU,LV=(0),A=(1)
*
         LTR   R6,R6                   Did we obtain tag data?
         BZ    ERR010                  No, no files available
         B     OPN300
*
*-- validate specific file owner
*
OPN200   EQU   *
         CLC   LCLNODE,TAGTOLOC        Is this file for this link?
         BNE   ERR016                  no, skip this file
         TM    FLAGS1,F1ACEE           Was security available?
         BZ    OPN300                  No; do not enforce selection
         CLC   USERID,TAGTOVM          Is file for this userid?
         BNE   ERR016                  no, skip this file
         DROP  R6                      TAG
         DROP  R8                      NCB
*
*-- Process the initial NETDATA control records from NETSPOOL
*
OPN300   EQU   *
         SR    R0,R0                   Code 0, process initial NETDATA
         L     R15,=A(NJENET)          -> NETDATA parsing routines
         BALR  R14,R15                 Process the control records
*
         B     OPN310(R15)             Branch based on error
OPN310   B     USR000              00  Normal, proceed.
         B     OPN400              04  File is not NETDATA
         B     EXIT08              08  Invalid NETDATA encountered
         B     ERR005              0C  Unexpected EOF on NETSPOOL
         B     ERR007              10  READ i/o error on NETSPOOL
         B     ERR030              14  INMTEXT detected, not supported
         B     ERR038              18  Record segments exceed LRECLv222
*
OPN400   EQU   *
         OI    FLAGS2,F2FLAT           Indicate file is a flat file
*
*-- Notify user of dataset and prompt for changes
*
*-- This routine will:
*   1. Obtain or make the dataset name that came from the Tag/NETDATA
*   2. Tell user that name and prompt for changes
*   3. Parse the changes
*
USR000   EQU   *
         LA    R7,INMF02A              -> 1st INMR02 record        v200
         USING INMFIELD,R7                                         v200
         NC    DSTYPE(2),DSTYPE        Was a DSTYPE key detected?  v200
         BZ    USR020                  No, we're good              v200
         CLI   DSTYPE+2,X'40'          PDSE program library?       v200
         BE    ERR035                  Can't support it            v200
         DROP  R7                      INMFIELD                    v200
*
USR020   EQU   *                                                   v200
         MVI   FLAGS4,X'00'            Reinit parse results flags
         L     R15,=A(NJENOT)          -> Notify user and parse rtn
         BALR  R14,R15
*
         LR    R1,R15                  RC to R1
         LR    R15,R0                  Any secondary RC to R15
         B     USR080(R1)              Branch based on error in R1
USR080   B     USR100              00  Normal, proceed.
         B     RCV920              04  User specified "END"
         B     RCV910              08  User specified "PURGE"
         B     ERR001              0C  IKJPARS err, RC in R15
         B     ERR026              10  PUTGET errr, RC in R15
*
*-- Did user enter a dataset name -and- member name on the prompt?
*-- If so, warn him that we are ignoring the member name.
*
USR100   EQU   *
         TM    FLAGS4,F4MEMINV         Was a member name specified?
         BZ    USR110                  No
*
         LA    R2,MSG021               msg: member name ignored
         BAL   R14,PUTLINE             Inform user
*
USR110   EQU   *
         TM    FLAGS2,F2FLAT           Flat non-NETDATA type file?
         BZ    RCV000                  No, process NETDATA
*
*-- Prepare attributes for a flat file
*
FLT000   EQU   *
         LA    R7,INMF02A              -> 1st INMR02 record
         USING INMFIELD,R7
         MVC   TDSNAME,FINALDS         Set up DSNAME to build
         MVI   DSNAME+1,44             Set DSNAME length for dynalloc
         MVC   DSORG+2(2),=X'4000'     Set DSORG=PS
         MVC   BLKSIZE+6(4),=F'0'      Set BLKSIZE to 0 to be computed
         MVI   RECFM+2,DCBRECF+DCBRECBR  Indicate RECFM=FB
         LA    R6,TAGDATA              -> TAG data
         USING TAG,R6
         LA    R1,80                   Assume punch data length
         TM    TAGINDEV,TYPPUN         Is this punch data?
         BO    FLT010                  Yes
         LA    R1,133                  Assign print data length
         OI    RECFM+2,DCBRECCA        Use ASA ctl char
*
FLT010   EQU   *
         STCM  R1,15,LRECL+6           Set LRECL
         SR    R0,R0                   Clear for multiply
         M     R0,TAGRECNM             Compute size of file
         ST    R1,FILESIZE+6           Set size in bytes for space calc
         DROP  R6,R7                   TAG,INMFIELD
*
*-- Prepare to receive the data
*
RCV000   EQU   *
         LA    R7,INMF02A              -> 1st INMR02 record
         USING INMFIELD,R7                                         v222
         ICM   R0,15,BLKSIZE+6         Get blocksize to use in srchv222
         C     R0,=F'32760'            BLKSIZE > 32760 MVS limit?  v222
         BH    ERR023                  Exit if invalid blksize     v222
         CLC   LRECL+6(4),=F'32760'    LRECL > 32760 MVS limit?    v222
         BH    ERR023                  Exit if invalid LRECL       v222
*
         TM    FLAGS1,F1INMR2B         Was there a second INMR02?
         BZ    RCV030                  No
         LA    R7,INMF02B              -> 2nd INMR02 record
*
*-- Locate a suitable volume to hold the new dataset
*
RCV030   EQU   *
         MVC   TVOLSER,USRVOL          Assume user specified volser
         TM    FLAGS3,F3VOLSER         Did user specify a volser?
         BO    RCV040                  Yes, we'll use that
         TM    FLAGS4,F4VOLSER         user specify a volser at prompt?
         BO    RCV040                  Yes, we'll use that
         TM    FLAGS2,F2UNIT           user specify a unit?        v200
         BO    RCV040                  Y, dont select a volume     v200
*
*                                      R0 must contain BLKSIZE or 0
         BAL   R14,GETVOL              Find a volume for allocation
         BZ    ERR022                  No volume found
*
*-- Start computing values and filling dynamic allocation text units
*
RCV040   EQU   *
         LA    R1,TVOLSER              -> selected volser          v200
         BAL   R14,FNDVOL              Get track sz of selected volv200
         BZ    ERR036                  Volume not online           v200
         LA    R1,INMF02A              -> 1st INMR02 record        v200
         L     R1,BLKSIZE+6-INMFIELD(,R1) Get target DSN blksize   v200
         CR    R1,R15                  Will block fit on track?    v200
         BH    ERR037                  No; were done here          v200
*
         BAL   R14,GETBSZ              Obtain final sizes, format
         STH   R1,TBLKSIZE             Set dynalloc block size
         STCM  R1,7,TBLKLEN            Set dynalloc space blk len
         STH   R2,TLRECL               Set dynalloc lrecl
         STC   R3,TRECFM               Set dynalloc recfm
*
         BAL   R14,GETSPACE            Compute space parameters
         STCM  R1,7,TPRIME             Set primary space in blocks
         STCM  R2,7,TSECND             Set secondary space in blocks
*
         MVC   TDSORG,DSORG+2          NETDATA DSORG to text unit
         MVC   TDSNAME,FINALDS         Set DSNAME to allocate
*
*
*
*-- Call NJEDYN to allocate the dataset
*
         LA    R0,DYNINMCP        04   allocate dataset for SEQL file
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
*
         B     RCV060(R15)             Branch on RC
RCV060   B     RCV200              00  Normal, proceed
         B     USR000              04  Dataset exists, reprompt
         B     EXIT08              08  All other errors
*
*
*-- Open the dataset
*
RCV200   EQU   *
         MVC   DDSYSUT1,TDDNAME        Save off the DDNAME returned
         MVC   NEWDS(DMYSEQL),DMYSEQ   Set up DCB
         LA    R6,NEWDS                -> DCB
         USING IHADCB,R6
         MVC   DCBBLKSI,TBLKSIZE       Set block size
         MVC   DCBLRECL,TLRECL         Set length
         MVC   DCBRECFM,TRECFM         Set format
         MVC   DCBDDNAM,DDSYSUT1       Set Dynamic DD name
         TM    DCBRECFM,DCBRECU        Using undefined records?
         BNO   RCV210                  No
*
         LH    R0,DCBBLKSI             Get dataset block size
         GETMAIN RU,LV=(0)             Get recd build buffer for RECFMU
         STM   R0,R1,NEWLEN            Save length and addr
         DROP  R6                      IHADCB
*
RCV210   EQU   *
         MVC   MACLIST(OPENL),OPEN     Move OPEN list
         OPEN  (NEWDS,OUTPUT),         Open the NEWDS dataset          X
               MF=(E,MACLIST)
         OI    FLAGS2,F2NEWOPN         Indicate DCB is open
*
         LA    R0,4                    Code 4, process NETDATA
         TM    FLAGS2,F2FLAT           Flat non-NETDATA type file?
         BZ    RCV220                  No, proceed with NETDATA
         LA    R0,8                    Code 8, process PRT/PUN file
*
RCV220   EQU   *
         L     R15,=A(NJENET)          -> data retreival routines
         BALR  R14,R15                 Process the records
*
         B     RCV230(R15)             Branch based on result RC
RCV230   B     RCV240              00  Normal, proceed.
         DC    AL4(0)              04  Not used
         B     EXIT08              08  Invalid NETDATA encountered
         B     ERR005              0C  Unexpected EOF on INDATASET
         B     ERR007              10  READ i/o error on INDATASET
         B     ERR030              14  INMTEXT detected, not supported
         B     ERR038              18  Record segments exceed LRECLv222
*
RCV240   EQU   *
         MVC   MACLIST(CLOSEL),CLOSE   Move close list
         CLOSE (NEWDS),                Close it                        X
               MF=(E,MACLIST)
         NI    FLAGS2,255-F2NEWOPN     Indicate file closed
*
         TM    FLAGS3,F3INDS           INDATASET specified?
         BZ    RCV250                  No, skip close
*
         MVC   MACLIST(CLOSEL),CLOSE   Move close list
         CLOSE (NETDATA),              Close it                        X
               MF=(E,MACLIST)
         NI    FLAGS2,255-F2NETOPN     Indicate NETDATA file closed
*
*
*
*-- If two INMR02 control records were found, then we need to run
*-- IEBCOPY to load a PDS from the unloaded file just processed above.
*
RCV250   EQU   *
         TM    FLAGS1,F1INMR2B         Was there a second INMR02?
         BZ    RCV950                  No. We're done
*
         LA    R7,INMF02A              -> 1st INMR02 record
         USING INMFIELD,R7
*
*-- Filling dynamic allocation text units for final dataset
*
         ICM   R1,15,BLKSIZE+6         Get the NETDATA blksize
         STH   R1,TBLKSIZE             Set dynalloc block size
         STCM  R1,7,TBLKLEN            Set dynalloc space blk len
         MVC   TLRECL,LRECL+8          Set dynalloc lrecl
         MVC   TRECFM,RECFM+2          Set dynalloc recfm
*
         BAL   R14,GETSPACE            Compute space parameters
         STCM  R1,7,TPRIME             Set primary space in blocks
         STCM  R2,7,TSECND             Set secondary space in blocks
*
         MVC   TDIRBLKS,DIRBLKS+7      Set directory blocks required
         TM    FLAGS2,F2DIR            Did user override with DIR? v200
         BZ    RCV255                  No                          v200
         MVC   TDIRBLKS,USRDIR+1       Set directory blocks req'd  v200
*
RCV255   EQU   *                                                   v200
         MVC   TDSORG,DSORG+2          NETDATA DSORG to text unit
         MVC   TDSNAME,FINALDS         Set DSNAME to allocate
*
*
*-- Call NJEDYN to allocate the final output dataset as "SYSUT2"
*
         LA    R0,DYNFINAL        10   allocate final dataset
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
*
         B     RCV260(R15)             Branch on RC
RCV260   B     RCV400              00  Normal, proceed
         B     RCV300              04  Dataset exists, reprompt
         B     EXIT08              08  All other errors
*
*-- Notify user of existing dataset and prompt for changes
*
*-- This routine will:
*   1. Obtain or make the dataset name that came from the Tag/NETDATA
*   2. Tell user that name and prompt for changes
*   3. Parse the changes
*
RCV300   EQU   *
         MVI   FLAGS4,X'00'            Reinit parse results flags
         L     R15,=A(NJENOT)          -> Notify user and parse rtn
         BALR  R14,R15
*
         LR    R1,R15                  RC to R1
         LR    R15,R0                  Any secondary RC to R15
         B     RCV310(R1)              Branch based on error in R1
RCV310   B     RCV320              00  Normal, proceed.
         B     RCV920              04  User specified "END"
         B     RCV910              08  User specified "PURGE"
         B     ERR001              12  IKJPARS err, RC in R15
         B     ERR026              16  PUTGET errr, RC in R15
*
*-- Did user enter a dataset name -and- and member name on the prompt?
*-- If so, warn him that we are ignoring the member name.
*
RCV320   EQU   *
         TM    FLAGS4,F4VOLSER         Was a new volser specified?
         BZ    RCV330                  No
         MVC   TVOLSER,USRVOL          Grab new volser
*
RCV330   EQU   *
         TM    FLAGS4,F4MEMINV         Was a member name specified?
         BZ    RCV250                  No, try to allocate again
*
         LA    R2,MSG021               msg: member name ignored
         BAL   R14,PUTLINE             Inform user
         B     RCV250                  Try to allocate again
*
*
*
*-- Prepare to launch IEBCOPY
*
RCV400   EQU   *
         MVC   DDSYSUT2,TDDNAME        Set replacement SYSUT2 DD
*
*-- Call NJEDYN to allocate the SYSIN dataset needed by IEBCOPY
*
         LA    R0,DYNSYSIN        08   allocate SYSIN for IEBCOPY
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXIT08                  Exit with dynalloc error
         MVC   DDSYSIN,TDDNAME         Save generated DDNAME
*
*-- Call NJEDYN to allocate the SYSPRINT dataset needed by IEBCOPY
*
         LA    R0,DYNSYSPR        12   allocate SYSPRINT for IEBCOPY
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXIT08                  Exit with dynalloc error
         MVC   DDSYSPR,TDDNAME         Save generated DDNAME
*
*-- Call NJEDYN to allocate the SYSUT3 dataset needed by IEBCOPY
*
         LA    R0,DYNSYSU3        14   allocate SYSUT3 temporary
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXIT08                  Exit with dynalloc error
         MVC   DDSYSUT3,TDDNAME        Set replacement SYSUT3 DD
*
*-- Invoke IEBCOPY
*
         MVC   CPYPLIST,COPYPARM       Move IEBCOPY parms to 24-bit stg
         MVC   DDLISTL,=AL2(DDLISTSZ)  Set IEBCOPY DD list length
         LA    R2,CPYPLIST
         LA    R3,DDLISTL
         MVC   MACLIST(LINKL),LINK     Move macro model
         LINK  EP=IEBCOPY,                                             x
               PARAM=((R2),(R3)),                                      x
               VL=1,                                                   x
               MF=(E,MACLIST)
         LTR   R5,R15                  Copy RC to R5
         BZ    RCV950                  Exit on success
*
*-- RECEIVE ended because IEBCOPY failed
*
RCV900   EQU   *
         LA    R2,MSGBLNK              -> blank line msg
         BAL   R14,PUTLINE
*
         MVC   LIST(4+L'MSG018T),MSG018 IEBCOPY fail msg
         CVD   R5,DBLE                 Convert IEBCOPY RC
         UNPK  LIST+37(2),DBLE
         OI    LIST+38,X'F0'           Fix sign
*
         LA    R2,LIST                 -> start of msg
         BAL   R14,PUTLINE             Display failure
         B     EXIT08
*
*-- User chose PURGE on the action prompt; purge the spool file
*-- (if not using INDATASET) and then exit.
*
RCV910   EQU   *
         TM    FLAGS3,F3INDS           Was INDATASET specified?
         BO    RCV920                  Y, exit with no action
         BAL   R14,PUR000              Purge spool file as requested
         LA    R2,MSGBLNK              -> blank line msg
         BAL   R14,PUTLINE
         LA    R2,MSG029               -> ended with nothing recv'd
         BAL   R14,PUTLINE
         B     EXIT00                  And we're done
*
*-- RECEIVE ended with no action taken
*
*-- Here if 'END' specified or attention received
*
RCV920   EQU   *
         LA    R2,MSGBLNK              -> blank line msg
         BAL   R14,PUTLINE
         LA    R2,MSG019               -> ended with no action
         BAL   R14,PUTLINE
         TM    FLAGS2,F2FEND           Was END forced in BATCH mode?
         BO    EXIT08                  Yes, force RC=8
         B     EXIT00
*
*-- RECEIVE ended successfully with dataset created and filled
*
*-- If the user at any time specified the PURGE option, remove
*-- the spool file that was received.
*
RCV950   EQU   *
*
RCV990   EQU   *
         LA    R2,MSGBLNK              -> blank line msg
         BAL   R14,PUTLINE
         MVC   LIST,BLANKS
         MVC   LIST(4+L'MSG017T),MSG017 Success msg
         LA    R1,LIST+4+L'MSG017T     -> next available byte
         MVI   0(R1),C''''             Move apost
         MVC   1(44,R1),FINALDS        Move final DSN
         TRT   1(45,R1),BLANK          Look for end of DSN
         MVI   0(R1),C''''             Move apost
         LA    R1,2(,R1)               -> skip over apost + 1 blank
         MVC   0(10,R1),=C'successful'
         LA    R1,10(,R1)              -> skip to end
         LA    R2,LIST                 -> start of msg
         SR    R1,R2                   Compute msg length
         STH   R1,LIST                 Set RDW
         BAL   R14,PUTLINE             Display success
*
         BAL   R14,PUR000              Purge the spool file if needed
         B     EXIT00
*
*
*-- Return the BLKSIZE value from the NETDATA, and adjust the
*-- RECFM and LRECL based on the NETDATA-unique variable formats when
*-- applicable.
*
*-- General guidelines and manipulations by this routine:
*
*-- 1. If the NETDATA LRECL is zero, this is unusual but don't alter
*--    any other DCB parameters; this covers the RECFM=U case.
*
*-- 2. If the NETDATA RECFM specifies the variable spanned records,
*--    leave all other parameters as is.  This file came from MVS.
*
*-- 3. If the NETDATA RECFM specifies the shortened variable format,
*--    e.g., RECFM=xx01 or xx02, then the LRECL must be increased
*--    by 4 bytes to account for a RDW to be inserted.
*
*-- 4. If the NETDATA RECFM specifies the shortened variable format,
*--    e.g., RECFM=xx01 or xx02, then the RECFM value used for
*--    dynamic allocation of the dataset must be modified to specify
*--    variable length records, as the variable X'40' bit may not
*--    be set in the NETDATA RECFM.
*
*-- 5. If the BLKSIZE is 0, the file probably came from VM; then
*--    do the following:
*--    a. Manufacture a suitable blksize as close to 4K as possible.
*--    b. If the LRECL > 4K, then make BLKSIZE=LRECL.
*--    c. For Fixed length records, force the RECFM X'10' bit to
*--       indicate blocked records, if BLKSIZE is not equal to LRECL.
*
*-- Entry: Fields BLKSIZE, LRECL, RECFM as decoded from NETDATA
*-- Exit:  R1 = BLKSIZE for use in dynamic allocation and DCB
*--        R2 = LRECL for use in dynamic allocation and DCB
*--        R3 = RECFM for use in dynamic allocation and DCB
*
GETBSZ   EQU   *
         ICM   R1,15,BLKSIZE+6         Get blocksize
         IC    R3,RECFM+2              Get DCB portion of NETDATA RECFM
         ICM   R2,15,LRECL+6           Get lrecl
         BZR   R14                     No LRECL?  leave everything be
         TM    RECFM+2,X'48'           Spanned variable records?
         BOR   R14                     Yes, use as specified
         TM    RECFM+3,X'03'           Shortened variable format?
         BZ    GETB010                 No
         LA    R2,4(,R2)               Add length to LRECL for RDW
         O     R3,=A(DCBRECV+DCBRECBR) Ensure DCB RECFM is VB
*
GETB010  EQU   *
         LTR   R1,R1                   Was there a blksize?
         BNZR  R14                     Use it if we have it
         TM    RECFM+2,X'40'           Variable format data?
         BO    GETB030                 Yes
         TM    RECFM+3,X'03'           Compressed variable format?
         BNZ   GETB030                 Yes, treat as variable
*fixed
         L     R1,=F'4096'             Get possible block size
         DR    R0,R2                   Compute # recs in 4096 block
         LTR   R1,R1                   Do any recs fit?
         BZ    GETB020                 No, so make blksize=lrecl
         SR    R0,R0                   Dispose of remainder
         MR    R0,R2                   Compute nearest block size
         O     R3,=A(DCBRECF+DCBRECBR) Set RECFM to FB
         BR    R14                     Return with BLKSIZE in R1
*
GETB020  EQU   *
         LR    R1,R2                   Make BLKSIZE=LRECL if LRECL>4096
         N     R3,=A(-1-DCBRECBR)      Turn off blocking
         BR    R14                     Return with BLKSIZE in R1
*
*variable
GETB030  EQU   *
         L     R1,=F'4096'             Get possible block size
         LA    R0,4092                 Possible size - 4 (for RDW)
         CR    R2,R0                   Will LRECL fit in possible size?
         BNHR  R14                     Yes, use the 4K blksize
*
GETB040  EQU   *
         LA    R1,4(,R2)               Mk BLKSIZE=LRECL+4 if LRECL>4092
         N     R3,=A(-1-DCBRECBR)      Turn off blocking
         BR    R14                     Return with BLKSIZE in R1
*
*-- Compute primary and secondary space values in # blocks
*
*-- Entry: R1 = blksize
*--        Field FILESIZE contains NETDATA estimated file size in bytes
*
*-- Exit:  R1 = # of primary blocks
*--        R2 = # of secondary blocks (always 10% of primary)
*
GETSPACE EQU   *
         ICM   R3,15,FILESIZE+6        Get approx size of file
         SR    R2,R2                   Clear for divide
         DR    R2,R1                   Compute # blocks needed
         LA    R3,1(,R3)               Always round up
         LR    R1,R3                   Return primary blocks in R1
         SR    R2,R2                   Clear for divide
         D     R2,=F'10'               Compute 1/10th of needed amt
         LA    R2,1(,R3)               Round up = secondary blks needed
         BR    R14                     Return with R1 & R2 values
         DROP  R7
*
*-- PURGE the spool file
*
*-- Conditions:
*-- 1.  If INDATASET was specified then there is no spool file to purge
*-- 2.  If PURGE was specified when the user was prompted for
*--     additional parameters, then purge the spool file and exit
*--     without receiving the file.
*-- 3.  If NOPURGE was specified on the command line (if not overridden
*--     by (2) above), then receive the file but do not purge it from
*--     the spool.
*-- 4.  Otherwise, PURGE is defaulted or explicity specified on the
*--     command line, receive the file and then purge it from spool.
*
PUR000   EQU   *
         TM    FLAGS3,F3INDS           INDATASET specified?
         BOR   R14                     Yes, PURGE has no meaning
         TM    FLAGS4,F4PURGE          PURGE specified on prompt?
         BO    PUR010                  Yes, do it
         TM    FLAGS3,F3PURGE          PURGE specified or defaulted?
         BZR   R14                     No; do not purge spool file
*
PUR010   EQU   *
         ST    R14,SV14PUR             Save return addr
         LA    R6,TAGDATA              -> area containing tag data
         USING TAG,R6
         LA    R8,NCB1                 -> NCB
         NSIO  TYPE=PURGE,             Purge the file                  x
               NCB=(R8),                                               x
               TAG=(R6)                -> Where tag data is
         LTR   R15,R15                 Any errors?
         BZ    PUR040                  No
         BAL   R14,FMT000              Display error
         B     EXIT08                  Exit on VSAM error
*
PUR030   EQU   *
         NSIO  TYPE=CLOSE,             Close the spool                 x
               NCB=(R8)
         NI    FLAGS2,255-F2NCBOPN     Indicate NETSPOOL closed
*
PUR040   EQU   *
         MVC   LIST(4+L'MSG028T),MSG028  Move file purged msg
         LH    R1,TAGID                Get the file ID
         DROP  R6                      TAG
         CVD   R1,DBLE
         UNPK  LIST+9(4),DBLE
         OI    LIST+12,X'F0'           Fix sign
         LA    R2,LIST                 -> msg text
         BAL   R14,PUTLINE             Inform user
         L     R14,SV14PUR             Reload return addr
         BR    R14                     Return
*
*
ERR001   EQU   *
         MVC   LIST(4+L'MSG001T),MSG001  Move msg to work area
         CVD   R15,DBLE                unpk IKJPARS RC
         UNPK  LIST+57(2),DBLE
         OI    LIST+58,X'F0'           Fix sign
         LA    R2,LIST                 -> msg
         B     ERRPUT                  Write msg                   v200
*
ERR004   EQU   *
         MVC   LIST(4+L'MSG004T),MSG004  Move msg to work area
         MVC   LIST+11(8),USRMEM       Plug in member name
         LA    R2,LIST                 -> msg
         B     ERRPUT                  Write msg                   v200
*
ERR005   EQU   *
         MVC   LIST(4+L'MSG005T),MSG005  Move msg text
         LA    R1,=CL9'INDATASET'      Assume reading from INDATASET
         TM    FLAGS3,F3INDS           Using INDATASET?
         BO    *+8                     We are
         LA    R1,=CL9'NETSPOOL'       NO, its NETSPOOL
         MVC   LIST+4+L'MSG005T(9),0(R1)  Move source of error
         LH    R1,LIST                 Get current msg length
         LA    R1,9(,R1)               Add on the source length
         STH   R1,LIST                 Put back
         LA    R2,LIST                 Unexpected EOF on xxxxxxxxx
         B     ERRPUT                  Write msg                   v200
*
ERR006   EQU   *
         LA    R2,MSG006               Not APF authorized
         B     ERRPUT                  Write msg                   v200
*
ERR007   EQU   *
         MVC   LIST(4+L'MSG007T),MSG007  Move msg text
         LA    R1,=CL9'INDATASET'      Assume reading from INDATASET
         TM    FLAGS3,F3INDS           Using INDATASET?
         BO    *+8                     We are
         LA    R1,=CL9'NETSPOOL'       NO, its NETSPOOL
         MVC   LIST+4+L'MSG007T(9),0(R1)  Move source of error
         LH    R1,LIST                 Get current msg length
         LA    R1,9(,R1)               Add on the source length
         STH   R1,LIST                 Put back
         LA    R2,LIST                 Read i/o error on INDATASET
         B     ERRPUT                  Write msg                   v200
*
ERR008   EQU   *
         LA    R2,MSG008               INDATASET is not NETDATA fmt
         B     ERRPUT                  Write msg                   v200
*
ERR009   EQU   *
         LA    R2,MSG009               INDATASET is not 80/F
         B     ERRPUT                  Write msg                   v200
*
ERR010   EQU   *
         LA    R2,MSG010               No files available to receive
         B     ERRPUT                  Write msg                   v200
*
ERR011   EQU   *
         LA    R2,MSG011               Specific file number not exis
         B     ERRPUT                  Write msg                   v200
*
ERR013   EQU   *
         LA    R2,MSG013               NJE38 is not active
         B     ERRPUT                  Write msg                   v200
*
ERR016   EQU   *
         LA    R2,MSG016               Cant receive another users file
         B     ERRPUT                  Write msg                   v200
*
ERR022   EQU   *
         LA    R2,MSG022               No suitable PUBLIC volume
         B     ERRPUT                  Write msg                   v200
*
ERR023   EQU   *
         LA    R2,MSG023               BLKSIZE/LRECL to large
         B     ERRPUT                  Write msg                   v200
*
ERR025   EQU   *
         LA    R2,MSG025               Need to run VERIFY
         B     ERRPUT                  Write msg                   v200
*
ERR026   EQU   *
         MVC   LIST(4+L'MSG026T),MSG026  Move msg to work area
         CVD   R15,DBLE                unpk PUTGET RC
         UNPK  LIST+49(2),DBLE
         OI    LIST+50,X'F0'           Fix sign
         LA    R2,LIST                 -> msg PUTGET failed
         B     ERRPUT                  Write msg                   v200
*
ERR030   EQU   *
         LA    R2,MSG030               INMTEXT detected not supported
         B     ERRPUT                  Write msg                   v200
*
ERR032   EQU   *
         LA    R2,MSG032               Security denied access NETSPOOL
         B     ERRPUT                  Write msg                   v200
*
ERR035   EQU   *                                                   v200
         LA    R2,MSG035               Incoming is a PDSE Prog Lib v200
         B     ERRPUT                  Write msg                   v200
*
ERR036   EQU   *                                                   v200
         LA    R2,MSG036               Volume not online           v200
         B     ERRPUT                  Write msg                   v200
*
ERR037   EQU   *                                                   v200
         LA    R2,MSG037               BLKSIZE to large for volume v200
         B     ERRPUT                  Write msg                   v200
*
ERR038   EQU   *                                                   v222
         LA    R2,MSG038               Input file recs exceed LRECLv222
         B     ERRPUT                  Write msg                   v222
*
ERRPUT   EQU   *                                                   v200
         BAL   R14,PUTLINE             Write error msg in R2       v200
         B     EXIT08                  Exit w RC=08                v200
*
EXIT00   EQU   *
         SR    R15,R15                 Set RC=0
         B     XIT000                  Clean up and exit
*
EXIT08   EQU   *
         LA    R15,8                   Set RC=8
         B     XIT000                  Clean up and exit
*
XIT000   EQU   *
         LA    R13,NJESA               Ensure using proper SA in case
*                                       we've come here due to ESTAE
         LR    R5,R15                  Save RC across shutdown
         ESTAE 0                       Disable ESTAE
*
         TM    FLAGS2,F2NETOPN         Is NETDATA open?
         BZ    XIT010                  No
         MVC   MACLIST(CLOSEL),CLOSE   Move close list
         CLOSE (NETDATA),              Close it                        X
               MF=(E,MACLIST)
*
XIT010   EQU   *
         TM    FLAGS2,F2NEWOPN         Is NEWDS open?
         BZ    XIT020                  No
         MVC   MACLIST(CLOSEL),CLOSE   Move close list
         CLOSE (NEWDS),                Close it                        X
               MF=(E,MACLIST)
*
XIT020   EQU   *
         TM    FLAGS2,F2NCBOPN         Is NETSPOOL open?
         BZ    XIT030                  No
         SR    R6,R6                   Ensure no tag data
         LA    R8,NCB1                 -> NCB
         NSIO  TYPE=CLOSE,             Close the spool                 x
               NCB=(R8)
*
XIT030   EQU   *
         L     R0,BLOCKLEN             Size of stg area
         ICM   R1,15,BLOCK             -> stg area
         BZ    XIT040                  Skip if never allocated
         FREEMAIN RU,LV=(0),A=(1)      Release it
*
XIT040   EQU   *
         L     R0,NEWLEN               Size of stg area
         ICM   R1,15,NEWBLK            -> stg area
         BZ    XIT050                  Skip if never allocated
         FREEMAIN RU,LV=(0),A=(1)      Release it
*                                                                       NJE00200
XIT050   EQU   *                                                        NJE00210
         LA    R3,DDLIST               -> list of DD's we allocated
         LA    R4,UNLISTSZ/8           # of DD list entries
*
XIT060   EQU   *
         CLC   =XL8'00',0(R3)          Unassigned DD?
         BE    XIT070                  Skip to next
*
         MVC   UDDNAME,0(R3)
         LA    R0,UNDYN           00   unalloc
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
*
XIT070   EQU   *                                                        NJE00210
         LA    R3,8(,R3)               -> next DD entry
         BCT   R4,XIT060               Continue unallocation scan
*
XIT080   EQU   *                                                        NJE00210
         TM    FLAGS1,F1AUSR           Special authorized user?
         BZ    QUIT                    Y, Don't need Auth SVC
         SR    0,0                     Use authorization SVC
         SR    1,1                      For HERC01/HERC02 only
         SVC   244                     Get un-authorized
*
QUIT     EQU   *                                                        NJE00210
         LR    R1,R10                  -> NJEWK main work area page
         L     R13,4(,R13)             -> caller's sa                   NJE00210
         ST    R5,16(,R13)             Set exit RC
         FREEMAIN RU,                                                  x
               LV=4096,                                                x
               A=(1)
         LM    R14,R12,12(R13)         Reload system's regs             NJE00220
         BR    R14                     Return                           NJE00240
         DROP  R12
*
*-- STAX attention exit
*
*-- Just post the PUTGET ECB and return.  PUTGET will fail with RC=8.
*
STAXXIT  EQU   *
         STM   R14,R12,12(R13)         Save
         LR    R12,R15                 Get base
         USING STAXXIT,R12
         L     R10,8(,R1)              -> NJEWK area
         USING NJEWK,R10
         POST  PUTECB,16               Post the PUTGET ECB
         OI    FLAGS4,F4ATTN           Indicate ATTN pressed       v201
         LM    R14,R12,12(R13)         Load
         DROP  R12
         BR    R14                     Return
*
         LTORG ,
*
DMYNPO   DCB   DDNAME=NETDATA,                                         X
               MACRF=(R),                                              X
               DSORG=PO,                                               X
               EODAD=EOD000
DMYNPOL  EQU   *-DMYNPO
*
DMYNPS   DCB   DDNAME=NETDATA,                                         X
               MACRF=(R),                                              X
               DSORG=PS,                                               X
               EODAD=EOD000
DMYNPSL  EQU   *-DMYNPS
*
*
DMYSEQ   DCB   DDNAME=0,                                               X
               MACRF=(PL),                                             X
               DSORG=PS,                                               X
               BFTEK=A
DMYSEQL  EQU   *-DMYSEQ
*
*
OPEN     OPEN  0,MF=L
OPENL    EQU   *-OPEN
CLOSE    CLOSE 0,MF=L
CLOSEL   EQU   *-CLOSE
LINK     LINK  EP=0,SF=L
LINKL    EQU   *-LINK
READ     READ  DMYDECB,SF,DMYNPO,MF=L
READL    EQU   *-READ
ESTAE    ESTAE 0,MF=L
ESTAEL   EQU   *-ESTAE
STAX     STAX  0,OBUF=(0,0),IBUF=(0,0),USADDR=0,MF=L
STAXL    EQU   *-STAX
*
COPYPARM DC    AL2(L'COPYOPT)
COPYOPT  DC    C'WORK=0512K'
COPYPRML EQU   *-COPYPARM                 TOTAL LENGTH OF PARM OPTION
*
ATTNMSG  DC   C'COMMAND TERMINATED DUE TO ATTENTION; PRESS ENTER TWICE'
*                                                                  v201
*********************
*  N J E C O M      *               NJECOM hosts small routines and
*                   *               frequently used constants that
*  Common routines  *               are available to all NJERxx csects
*  and constants    *               via base register 11
*                   *
*********************
*
NJECOM   CSECT
         DC    A(0)                 No branch around constants
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJECOM'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
         USING NJECOM,R11
*
*-- GET000 is used to read a block from the INDATASET or to read
*-- a record from NETSPOOL.
*
*-- Entry:  INDATASET or NETSPOOL must be OPEN.
*-- Exit:  R0 = length of data read
*--        R1 -> data read
*--        R15= RC.  0=OK
*--                  4=Unexpected end of file
*--                  8=Read i/o error
*
GET000   EQU   *
         ST    R14,SV14GET
         TM    FLAGS3,F3INDS        INDATASET specified?
         BZ    GET030               No, use NETSPOOL
*
         LA    R2,NETDATA           -> DCB
         L     R0,BLOCK             -> read buffer
*
         READ  DECB,SF,(R2),(R0),'S',MF=E   Read block
         CHECK DECB
*
         CLI   DECB,X'7F'           Was read successful?
         BNE   GET090               No, read failed
*
         L     R0,BLOCKLEN          Get current block size
         L     R15,DECB+16          -> IOB addr
         SH    R0,14(,R15)          Compute size of block read
         L     R1,BLOCK             Return buffer addr
         SR    R15,R15              Set RC=0
         L     R14,SV14GET
         BR    R14                  Return w/len & addr in R0,R1
*
GET030   EQU   *
         LA    R1,NCB1              -> NCB
         NSIO  TYPE=GET,            TAG data contains file #           x
               NCB=(1),                                                x
               AREA=LIST                                           v200
         LTR   R15,R15              Any errors?
         BZ    GET040               No
         BAL   R14,FMT000           Display error
         B     GET090
*
GET040   EQU   *
         MVC   REC(133),BLANKS      Init receiving field           v200
         LH    R2,NCBRECLN-NCB(,R1) Get the record length          v200
         BCTR  R2,0                 Adjust for execute             v200
         EX    R2,MVSPL             Mv spool record to phy rec areav200
         LA    R1,REC               -> record
         LA    R0,80                Always 80
         SR    R15,R15              Set RC=0
         L     R14,SV14GET
         BR    R14                  Return w/len & addr in R0,R1
*
MVSPL    MVC   REC(0),LIST          executed instr                 v200
*
GET090   EQU   *
         LA    R15,8                Set RC=8 = Read error
         L     R14,SV14GET
         BR    R14                  Return
*
EOD000   EQU   *
         LA    R15,4                Set RC=4 = unexpected EOF
         L     R14,SV14GET
         BR    R14                  Return w/len & addr in R0,R1
*
*-- Find a PUBLIC volume for use in allocations
*
*-- Entry:  R0 = blksize of dataset to be allocated
*-- Exit:   CC=0 if no volume selected
*--         CC<>0 if volume selected, and,
*--           TVOLSER,DEVINFO fields are filled in.
*
*-- Uses R15-R3
*
GETVOL   EQU   *
         LA    R1,DISKS            -> dasd characteristics table
         USING DASDTAB,R1
*
GETV010  EQU   *
         SR    R3,R3               Clear for ICM
         L     R2,16               -> CVT
         USING CVT,R2
         L     R2,CVTILK2          -> UCB Lookup table
*
GETV020  EQU   *
         LA    R2,2(,R2)           -> first table entry
*
         CLC   0(2,R2),=X'FFFF'    End of UCBs?
         BE    GETV030             Y
         ICM   R3,3,0(R2)          -> UCB
         BZ    GETV020             Skip empty table slot
         USING IEFUCBOB,R3
         TM    UCBSTAT,UCBONLI     Is device online?
         BZ    GETV020             N, next UCB
         TM    UCBTBYT3,UCB3DACC   Direct access device?
         BZ    GETV020             N, next UCB
         CLC   UCBTBYT4,DASDTYPE   Preferred device type?
         BNE   GETV020             N, next UCB
         TM    UCBSTAB,UCBBPUB     PUBLIC volume?
         BZ    GETV020             N
         LA    R15,DASDSIZE        -> full track size for device
         CLC   DASDHTRK,=AL2(0)    Is a half-track blksize avail?
         BE    *+8                 No
         LA    R15,DASDHTRK        Yes, use 1/2 track for device
         CLM   R0,3,0(R15)         Will file blksize fit?
         BH    GETV030             Too large, get another dasd type
*
         ST    R1,DEVINFO          Save ptr to selected dev type
*                                  UCBNAME contains C'cuu'
         MVC   TVOLSER,UCBVOLI     Save selected volser to text unit
         CLI   *,1                 Set CC to non zero
         BR    R14
*
GETV030  EQU   *
         LA    R1,DASDLEN(,R1)     Next DASD device preference
         CLI   0(R1),X'FF'         End of DASD table?
         BER   R14                 Y, no suitable unit found, cc=0
         B     GETV010             Search again
         DROP  R3                  IEFUCBOB
         DROP  R2                  CVT                             v200
         DROP  R1                  DASDTAB
*
*-- Find a volser in the UCBs so we can get its devtype (cant use  v200
*-- DEVTYPE because it is not allocated yet) and determine its     v200
*-- maximum track size.                                            v200
*
*-- Entry:  R1 -> CL'volser' to be located                         v200
*-- Exit:   CC=0 if the volser was not found                       v200
*--         CC<>0 if volume found; and R15 = track size in bytes   v200
*
*-- Uses R15-R3                                                    v200
*
FNDVOL   EQU   *                                                   v200
         SR    R3,R3               Clear for ICM                   v200
         L     R2,16               -> CVT                          v200
         USING CVT,R2                                              v200
         L     R2,CVTILK2          -> UCB Lookup table             v200
         DROP  R2                  CVT                             v200
*
FNDV020  EQU   *                                                   v200
         LA    R2,2(,R2)           -> first table entry            v200
*                                                                  v200
         CLC   0(2,R2),=X'FFFF'    End of UCBs?                    v200
         BE    FNDV090             Y                               v200
         ICM   R3,3,0(R2)          -> UCB                          v200
         BZ    FNDV020             Skip empty table slot           v200
         USING IEFUCBOB,R3                                         v200
         TM    UCBSTAT,UCBONLI     Is device online?               v200
         BZ    FNDV020             N, next UCB                     v200
         TM    UCBTBYT3,UCB3DACC   Direct access device?           v200
         BZ    FNDV020             N, next UCB                     v200
         CLC   UCBVOLI,0(R1)       Selected volser?                v200
         BNE   FNDV020             No, next UCB                    v200
*
         LA    R1,DISKS            -> dasd characteristics table   v200
         USING DASDTAB,R1                                          v200
*
FNDV030  EQU   *                                                   v200
         CLI   0(R1),X'FF'         End of DASD types?              v200
         BE    FNDV090             Cant match volser vs devtype    v200
*
         CLC   UCBTBYT4,DASDTYPE   Match the device type?          v200
         BE    FNDV080             Yes                             v200
         LA    R1,DASDLEN(,R1)     Next DASD device in table       v200
         B     FNDV030             Look again                      v200
*
FNDV080  EQU   *                                                   v200
         SR    R15,R15             Clear for IC                    v200
         ICM   R15,3,DASDSIZE      Get full track size for device  v200
         CLI   *,1                 Set CC to non zero              v200
*
FNDV090  EQU   *                                                   v200
         BR    R14                 Return w CC=0 or CC<>0          v200
         DROP  R3                  IEFUCBOB                        v200
         DROP  R1                  DASDTAB                         v200
*
*
*-- Format VSAM NETSPOOL errors
*
*
FMT000   EQU   *
         STM   R14,R2,PARSA+12         Borrow NJEPAR save area
         LA    R15,0(,R14)  Clear high, Get addr of call to this rtn
         L     R2,NJESA+4              -> system provided FSA
         L     R2,16(,R2)              Get R15's entry point addr
         LA    R2,0(,R2)               Ensure high byte clear
         SR    R15,R2                  Compute offset of call
         MVC   LIST+0(4+L'MSG024T),MSG024 Move msg text
         MVC   LIST+55(8),5(R2)        Move csect name
         TRT   LIST+55(9),BLANK        Look for end of csect name
         MVI   0(R1),C'+'
*
         ST    R15,DBLE                Save call offset to work area
         UNPK  TWRK(5),DBLE+2(3)       Add zones
         TR    TWRK(4),HEXTRAN-240     Display hex
         MVC   1(4,R1),TWRK            Move call offset to msg
*
         LA    R15,NCB1
         UNPK  TWRK(5),NCBRTNCD-NCB(3,R15)  Add zones
         TR    TWRK(4),HEXTRAN-240
         MVC   LIST+35(4),TWRK         Move rtncd/errcd
*
         UNPK  TWRK(3),NCBREQ-NCB(2,R15)  Add zones
         TR    TWRK(2),HEXTRAN-240
         MVC   LIST+45(2),TWRK         Move req code
*
         L     R1,NCBMACAD-NCB(,R15)   Get failing VSAM macro addr
         LA    R1,0(,R1)               Clear high byte
         S     R1,=V(NJESPOOL)         Compute offset into NJESPOOL rtn
         ST    R1,DBLE
         UNPK  TWRK(5),DBLE+2(3)       Add zones
         TR    TWRK(4),HEXTRAN-240     Display hex
         MVC   LIST+50(4),TWRK         Move NJESPOOL offset to msg
*
         LA    R2,LIST
         BAL   R14,PUTLINE
*
FMT090   EQU   *
         LM    R14,R2,PARSA+12         Restore caller regs
         BR    R14                     Return
*
*-- Write a single line to terminal
*
*-- Entry: R2 -> output msg (RDW+msg text)
*-- Exit:  R15 = RC from PUTLINE
*
PUTLINE  EQU   *
         TM    FLAGS3,F3QUIET          QUIET mode enabled?
         BZ    PUT010                  No, proceed
         CLI   3(R2),1                 Suppress this msg in QUIET mode?
         BER   R14                     Yes
*
PUT010   EQU   *
         ST    R14,SV14LN              Save return
         XC    PUTECB,PUTECB           Clear PUTLINE ECB
         L     R15,CPARMS              -> command input CPPL
         USING CPPL,R15
         LA    R1,IOPLAREA             -> IOPL
         USING IOPL,R1
         MVC   IOPLUPT,CPPLUPT         Set UPT ptr
         MVC   IOPLECT,CPPLECT         Set ECT ptr
         DROP  R15                     CPPL
*
         MVC   TWRK(PBL),PB            Move macro model
         PUTLINE PARM=TWRK,            Write a line                    x
               ECB=PUTECB,                                             x
               OUTPUT=((R2),TERM,SINGLE,DATA),                         x
               MF=(E,(1))
         DROP  R1                      IOPL
         L     R14,SV14LN              Load return
         BR    R14
*
*
*-- Write a single line to terminal and prompt for response
*
*-- Entry: OLDMSGAD points to output message
*-- Exit:  R15 = RC from PUTGET
*--        PGPBIBUF -> input data (if any)
*
PUTGET   EQU   *
         ST    R14,SV14LN              Save return
         XC    PUTECB,PUTECB
         L     R15,CPARMS              -> command input CPPL
         USING CPPL,R15
         LA    R1,IOPLAREA             -> IOPL
         USING IOPL,R1
         MVC   IOPLUPT,CPPLUPT         Set UPT ptr
         MVC   IOPLECT,CPPLECT         Set ECT ptr
         DROP  R15                     CPPL
*
         MVC   MACLIST(PGTL),PGT       move macro model
         PUTGET PARM=MACLIST,                                          x
               ECB=PUTECB,                                             x
               OUTPUT=(OLD,SINGLE,PROMPT),                             x
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     x
               TERMGET=(EDIT,WAIT),                                    x
               MF=(E,(1))
         DROP  R1                      IOPL
*
         LA    R5,MACLIST
         USING PGPB,R5
         L     R1,PGPBIBUF             -> input buffer acquired
         DROP  R5
         L     R14,SV14LN              Load return
         BR    R14
*
*-- Get status of NJE38
*
*-- Entry: R1=0 (no spool dsn needed), or, R1-> 44-char spool DSN area
*-- Exit:  RC=0  NJE38 is active; R1-> NJE38 CSA block
*--        RC<>0 NJE is not active.
*
CHK000   EQU   *
         LA    R1,TDSNAME              => where to place spool DSN v210
         L     R15,=V(NJESYS)          -> ENQ finder               v210
         BALR  R14,R15                 Check if NJE38 already act  v210
         LTR   R15,R15                 Set CC (RC=0 NJE38 active)  v210
         BNZR  R2                      Return if NJE38 inactive    v210
         MVC   LCLNODE,NJ38NODE-NJ38CSA(R1)  Save off lcl node namev210
         MVC   DEFUSER,NJ38DUSR-NJ38CSA(R1)  Save off default user v210
         BR    R2                      Return; NJE38 active        v210
*
         LTORG
*
PB       PUTLINE MF=L
PBL      EQU   *-PB
PGT      PUTGET MF=L
PGTL     EQU   *-PGT
*
NJE38Q   DC    CL8'NJE38'              QNAME
NJERCON  DC    CL8'NJEINIT'            RNAME (first 8 bytes)
*
*
*
BLANKS   DC    CL136' '                                            v200
NONBLANK DC    64X'FF',X'00',191X'FF'  TR Table to locate nonblank
BLANK    DC    64X'00',X'FF',191X'00'  TR Table to locate blanks
DOTS     DC    75X'00',X'FF',180X'00'  TR Table to locate '.' char
HEXTRAN  DC    CL16'0123456789ABCDEF'  Translate table
*
*-- RECEIVE messages
*
*-- Note:  a '1' after the length indicates suppress this msg if QUIET
*
MSGBLNK  DC    Y(4+L'MSGBLNKT,1)
MSGBLNKT DC    C' '
*
MSG000   DC    Y(4+L'MSG000T,1)
MSG000T  DC    C'NJE38 RECEIVE &VERS'
*
MSG001   DC    Y(4+L'MSG001T,0)
MSG001T  DC    C'Error parsing RECEIVE command parameters. IKJPARS RC=yx
               y (dec)'
*                456789012345678901234567890123456789012345678901234567
MSG002   DC    Y(4+L'MSG002T,0)
MSG002T  DC    C' '                   UNUSED - AVAILABLE
*
MSG003   DC    Y(4+L'MSG003T,0)
MSG003T  DC    C'Invalid or unsupported NETDATA detected; error code x,*
                record '
*
MSG004   DC    Y(4+L'MSG004T,0)
MSG004T  DC    C'Member xxxxxxxx was not found'
*                456789012345678901234567890123456789012345678901234567
*
MSG005   DC    Y(4+L'MSG005T,0)
MSG005T  DC    C'Unexpected end of file encountered reading '
*
MSG006   DC    Y(4+L'MSG006T,0)
MSG006T  DC    C'The RECEIVE command is not APF-authorized'
*
MSG007   DC    Y(4+L'MSG007T,0)
MSG007T  DC    C'I/O error reading '
*
MSG008   DC    Y(4+L'MSG008T,0)
MSG008T  DC    C'Specified INDATASET does not contain NETDATA formattedx
                records'
*
MSG009   DC    Y(4+L'MSG009T,0)
MSG009T  DC    C'Specified INDATASET must be LRECL=80, RECFM=F or FB'
*
MSG010   DC    Y(4+L'MSG010T,0)
MSG010T  DC    C'No files are available to receive'
*
MSG011   DC    Y(4+L'MSG011T,0)
MSG011T  DC    C'Specified file number does not exist'
*
MSG012   DC    Y(4+44+L'MSG012T,0)
MSG012T  DC    C'Allocation error xxxxxxxx, DSN='
*
MSG013   DC    Y(4+L'MSG013T,0)
MSG013T  DC    C'NJE38 is not active'
*
MSG014   DC    Y(4+L'MSG014T,1)
MSG014T  DC    C'Receiving '
*
MSG015   DC    Y(4+L'MSG015T,1)
MSG015T  DC    C' Enter receive parameters or ''PURGE'' or ''END'' +'
*
MSG016   DC    Y(4+L'MSG016T,0)
MSG016T  DC    C'Cannot receive file destined for another user'
*
MSG017   DC    Y(4+L'MSG017T,1)
MSG017T  DC    C'Receive into '
*
MSG018   DC    Y(4+L'MSG018T,0)
MSG018T  DC    C'Receive failed due to IEBCOPY RC=xx'
*                456789012345678901234567890123456789012345678901234567
*
MSG019   DC    Y(4+L'MSG019T,0)
MSG019T  DC    C'RECEIVE ended with no action taken'
*
MSG020   DC    Y(4+L'MSG020T,1)
MSG020T  DC    C' Enter receive parameters or ''END'' +'
*
MSG021   DC    Y(4+L'MSG021T,0)
MSG021T  DC    C'Member name ignored'
*
MSG022   DC    Y(4+L'MSG022T,0)
MSG022T  DC    C'No suitable PUBLIC volume found that can contain this x
               dataset'
*
MSG023   DC    Y(4+L'MSG023T,0)
MSG023T  DC    C'The BLKSIZE or LRECL of the received file exceeds the x
               32760-byte MVS limit'
*
MSG024   DC    Y(4+L'MSG024T,0)
MSG024T  DC    C'ERROR:  NETSPOOL RTNCD/ERRCD=X''0000'',REQ=01,O=1234,Mx
               MMMMMMM     '
*
MSG025   DC    Y(4+L'MSG025T,0)
MSG025T  DC    C'Unable to open NETSPOOL. Run IDCAMS VERIFY against thex
                NETSPOOL dataset'
*
MSG026   DC    Y(4+L'MSG026T,0)
MSG026T  DC    C'Error in terminal prompt message.  PUTGET RC=yy (dec)'
*                456789012345678901234567890123456789012345678901234567
*
MSG027   DC    Y(4+L'MSG027T,0)
MSG027T  DC    C' exists'
*
MSG028   DC    Y(4+L'MSG028T,1)
MSG028T  DC    C'File(xxxx) purged from NJE38 spool'
*
MSG029   DC    Y(4+L'MSG029T,0)
MSG029T  DC    C'RECEIVE ended without receiving anything'
*
MSG030   DC    Y(4+L'MSG030T,0)
MSG030T  DC    C'RECEIVE halted; unsupported message text (INMTEXT) detx
               ected'
*
MSG031   DC    Y(4+L'MSG031T,0)
MSG031T  DC    C' does not exist'
*
MSG032   DC    Y(4+L'MSG032T,0)
MSG032T  DC    C'Access to the NETSPOOL dataset denied due to security x
               settings'
*
MSG033   DC    Y(4+L'MSG033T,0)                                    v200
MSG033T  DC    C'Volume unavailable or conflicting with specified UNIT x
               name'                                               v200
*
MSG034   DC    Y(4+L'MSG034T,0)                                    v200
MSG034T  DC    C'The specified UNIT name is not defined in the system' x
                                                                   v200
*
MSG035   DC    Y(4+L'MSG035T,0)                                    v200
MSG035T  DC    C'Incoming file is a PDSE Program Library which cannot bx
               e supported'                                        v200
*
MSG036   DC    Y(4+L'MSG036T,0)                                    v200
MSG036T  DC    C'The selected volume is not online'                v200
*
MSG037   DC    Y(4+L'MSG037T,0)                                    v200
MSG037T  DC    C'The incoming file block size is too large to fit on thx
               e selected volume'                                  v200
*
MSG038   DC    Y(4+L'MSG038T,0)                                    v222
MSG038T  DC    C'The incoming file contains logical records that exceedx
                the LRECL of the dataset'                          v222
*                                                                       NJE00250
*                                                                       NJE00250
* DASD Characteristics in order of selection preference                 NJE00250
*                                                                       NJE00250
* NOTE:  3380 DASD exist in this table twice.  The reason for           NJE00250
*        this is to allow a better identification of the DASD           NJE00250
*        type required by "GETVOL" based on the received file's         NJE00250
*        BLKSIZE.  The file could be half-track blocked, so we          NJE00250
*        need to account for that in selecting a device type.           NJE00250
*        However, the file could be using a BLKSIZE that is             NJE00250
*        larger than the half track size despite the inefficiency.      NJE00250
*        For these cases, the last 3380 entry does not have             NJE00250
*        a half-track size value, allowing the GETVOL search to
*        succeed using the full track size which would accomodate
*        any MVS BLKSIZE that could be received.
*
*                                                                       NJE00250
DISKS    EQU   * TYP    CYLS    TRKS     BYTES    1/2-TRK
         DC    X'0E',AL2(885),AL1(15),AL2(47476),AL2(23476)  3380 A/D/J
         DC    X'0B',AL2(555),AL1(30),AL2(19069),AL2(0)      3350
         DC    X'0C',AL2(959),AL1(12),AL2(35616),AL2(17600)  3375
         DC    X'0F',AL2(1113),AL1(15),AL2(56664),AL2(27998) 3390-1
         DC    X'0D',AL2(808),AL1(19),AL2(13030),AL2(0)      3330-11
         DC    X'09',AL2(404),AL1(19),AL2(13030),AL2(0)      3330-1
         DC    X'0A',AL2(696),AL1(12),AL2(8368),AL2(0)       3340-70
         DC    X'08',AL2(200),AL1(20),AL2(7294),AL2(0)       2314
         DC    X'0E',AL2(885),AL1(15),AL2(47476),AL2(0)      3380 A/D/J
         DC    X'FF'                End of table
*                                                                       NJE00250
DASDTAB  DSECT
DASDTYPE DS    X                    Dasd UCB device type code
DASDCYLS DS    AL2                  Number of cylinders
DASDTRKS DS    AL1                  Number of tracks
DASDSIZE DS    AL2                  Bytes per track
DASDHTRK DS    AL2                  Bytes per half-track block or 0
DASDLEN  EQU   *-DASDTAB            Size of one DASDTAB entry
*
*                                                                       NJE00250
*********************
*  N J E N O T      *               NJENOT tells the user the chosen
*                   *               DSN of the file and prompts for
*  User notify and  *               changes
*  prompt           *
*                   *
*********************
*
*
NJENOT   CSECT
         B     28(,R15)               BRANCH AROUND EYECATCHERS
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJENOT'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
*
         STM   R14,R12,12(R13)         Save Regs                        NJE00050
         LR    R12,R15                 Base                             NJE00060
         USING NJENOT,R12                                               NJE00070
         USING NJEWK,R10
         ST    R13,NOTSA+4             SAVE prv S.A. ADDR               NJE00080
         LA    R2,NOTSA                -> my save area
         ST    R2,8(,R13)              Plug it into prior SA
         LR    R13,R2
*
NOT000   EQU   *
         BAL   R14,BDS000              Build final dataset name
         BAL   R14,NTF000              Build notification msg
*
         TM    FLAGS2,F2FEND           END forced previously?
         BO    XITNOT04                Force 'END' again
*
         LA    R2,LIST                 -> MSG014 receiving dataset...
         BAL   R14,PUTLINE             Notify user
*
         TM    FLAGS1,F1BATCH          Are we in BATCH mode?
         BO    NOT090                  Yes, special handling
         TM    FLAGS3,F3NPRMPT         Are we in NOPROMPT mode?
         BO    NOT090                  Yes, special handling
*
         LA    R1,MSG015               -> enter parameters prompt
         TM    FLAGS3,F3INDS           Was INDATASET specified?
         BZ    NOT010                  No
         LA    R1,MSG020               Use MSG020 if INDS in use
*
NOT010   EQU   *
         ST    R1,OLDMSGAD             Set it in the OLD
         BAL   R14,PUTGET              Prompt the user
         C     R15,=F'8'               PUTGET ECB posted (attn recv'd)?
         BE    XITNOT04                Yes, treat as 'END' specified
         LTR   R0,R15                  PUTGET RC to R0
         BNZ   XITNOT16                Exit if putget error
*
         ST    R1,OLDMSGAD             Temp save of PUTGET input ptr
         LA    R0,4                    Code 4: use prompt parameters
*                                      R1 -> PUTGET input buffer
         L     R15,=A(NJEPAR)          -> parse routine
         BALR  R14,R15
         LR    R5,R15                  Any errors to R5
*
         TM    FLAGS4,F4ATTN           Was ATTN pressed?           v201
         BO    XITNOT04                Y, immediate exit           v201
*
         L     R1,OLDMSGAD             -> PUTGET input buffer
         LH    R0,0(,R1)               Get length of area
         O     R0,=X'01000000'         Set SP=1
         FREEMAIN R,LV=(0),A=(1)       Free the PUTGET msg buffer
*
         LTR   R0,R5                   Now put IKJPARS RC in R0
         BNZ   XITNOT12                Display IJKPARS RC
         TM    FLAGS4,F4END            Was END specified?
         BO    XITNOT04                Exit if END
         TM    FLAGS4,F4PURGE          Was PURGE specified?
         BO    XITNOT08                Exit if PURGE
         B     XITNOT00
*
*-- If running BATCH, allow one trip through here to exit cleanly
*-- to simulate pressing "enter" with no parameters.  On all
*-- subsquent calls to NJENOT, F2END will be set (if BATCH) so
*-- we can force END in order to prevent looping in batch.
*
NOT090   EQU   *
         OI    FLAGS2,F2FEND           Indic force END from now on
         B     XITNOT00                Allow null prompt this time
*
*-- Build DSN
*
*-- DSN Strategy:  The DSN from the NETDATA will be extracted and
*-- the first qualifer eliminated, unless the DSN is only one
*-- qualifier.  Then, the remaining part of that DSN will be appended
*-- to the receiving user's userid  (the userid will be the new
*-- first qualifier.
*
*-- If the incoming file is a flat file (not NETDATA) the DSNAME is
*-- manufactured from the filename and filetype fields of the TAG data.
*
*-- If DATASET was specified on the command line (F3DS=1) then we
*-- will attempt to use that as is and exit the build DS routine.
*
BDS000   EQU   *
         TM    FLAGS3,F3DS             Is final dataset already set?
         BOR   R14                     Exit if we already have it
         MVC   FINALDS,BLANKS          Init
         MVC   FINALDS(8),USERID       Move userid
         TM    FLAGS2,F2FLAT           Is incoming file a flat file?
         BO    BDS020                  Yes, use tag data
*
         LA    R7,INMF02A              -> first INMR02 results
         USING INMFIELD,R7
*
         SR    R4,R4                   Clear for IC
         ICM   R4,3,DSNAME             Get NETDATA DSN length
         LA    R1,DSNAME+2             Assume DSN has 1 qualifier
         TRT   DSNAME+2(10),DOTS       Look for end of 1st qualifier
         BZ    BDS010                  Branch if only 1 qualifier
         LA    R1,1(,R1)               Skip the delim after 1st qualifr
         LR    R0,R1                   Copy position
         LA    R2,DSNAME+2             Start of DSN
         SR    R0,R2                   Compute length we are skipping
         SR    R4,R0                   Reduce remaining DSN length
*
BDS010   EQU   *
         LR    R3,R1                   Save start of NETDATA DSN
         TRT   FINALDS(9),BLANK        Look for end of userid
         MVI   0(R1),C'.'              Add delimiter
         LA    R1,1(,R1)               -> next available byte
         LA    R2,FINALDS              -> start of userid
         LR    R0,R1                   Copy next available byte addr
         SR    R0,R2                   Compute userid. length
         LA    R15,43                  Total DSN length -1 for execute
         SR    R15,R0                  Compute remaining available
         CR    R15,R4                  Use lesser remaining length
         BL    *+6                     Br if TDSNAME length is less
         LR    R15,R4                  No, NETDATA DSN len is less
         EX    R15,MVCDSN              Move the rest of it
*MVCDSN  MVC   0(0,R1),0(R3)
         CLI   FINALDS+43,C'.'         Last char of DSN is a delim?
         BNER  R14                     No
         MVI   FINALDS+43,C' '         Blank it out
         DROP  R7                      INMFIELD
         BR    R14                     Return
*
BDS020   EQU   *
         LA    R4,TAGDATA              -> Spool file's tag data
         USING TAG,R4
*
         LA    R1,FINALDS              -> final dsname area
         TRT   0(9,R1),BLANK           Look for end of userid
         MVI   0(R1),C'.'              Add delimiter
         LA    R1,1(,R1)               -> next available byte
         MVC   0(8,R1),TAGNAME         Insert tag's file name
         TRT   0(9,R1),BLANK           Find the end of it
         MVI   0(R1),C'.'              Add delimiter
         LA    R1,1(,R1)               -> next available byte
         MVC   0(8,R1),TAGTYPE         Insert tag's file name
         DROP  R4                      TAG
         BR    R14                     Return
*
*
MVCDSN   MVC   0(0,R1),0(R3)           executed instr
*
*
*-- Build msg containing incoming dataset name from the netdata
*
NTF000   EQU   *
         MVC   LIST,BLANKS
         MVC   LIST(4+L'MSG014T),MSG014  'Receiving ...'
         LA    R1,LIST+4+L'MSG014T     -> next available byte
         MVI   0(R1),C''''             Move apost
         LA    R1,1(,R1)               Next byte
*
         TM    FLAGS2,F2FLAT           Is incoming file a flat file?
         BO    NTF020                  Yes, use tag data
*
         LA    R7,INMF02A              -> First INMR02 data
         USING INMFIELD,R7
         MVC   0(44,R1),DSNAME+2       Move incoming DSN
         TRT   0(45,R1),BLANK          Look for end of DSN
         MVI   0(R1),C''''             Move apost
         LA    R1,2(,R1)               -> skip over apost + 1 blank
         MVC   0(4,R1),=C'from'
         LA    R1,5(,R1)               -> where to put node id
         LA    R7,INMF01               -> INMR01 data
         USING INMFIELD,R7
         MVC   0(8,R1),FNODE+2         Move from node name
         TRT   0(9,R1),BLANK           Look for end of nodeid
         MVI   0(R1),C'('              Insert (
         MVC   1(8,R1),FUSER+2         Move from user name
         DROP  R7                      INMFIELD
         TRT   1(9,R1),BLANK           Look for end of userid
         MVI   0(R1),C')'              Insert )
         LA    R1,1(,R1)               -> end of msg
         LA    R0,LIST                 -> start of msg
         ST    R0,OLDMSGAD             Set msg ptr
         SR    R1,R0                   Compute length of msg
         STH   R1,LIST                 Set length of msg for PUTGET
         BR    R14                     Return
*
*-- Build msg containing incoming dataset name from the tag data
*
NTF020   EQU   *
         LA    R4,TAGDATA              -> Spool file's tag data
         USING TAG,R4
*
         MVC   0(8,R1),TAGNAME         Insert tag's file name
         TRT   0(9,R1),BLANK           Find the end of it
         LA    R1,1(,R1)               -> next available byte
         MVC   0(8,R1),TAGTYPE         Insert tag's file name
         TRT   0(9,R1),BLANK           Find the end of it
         MVI   0(R1),C''''             Move apost
         LA    R1,2(,R1)               -> skip over apost + 1 blank
         MVC   0(4,R1),=C'from'
         LA    R1,5(,R1)               -> where to put node id
         MVC   0(8,R1),TAGINLOC        Move from node name
         TRT   0(9,R1),BLANK           Look for end of nodeid
         MVI   0(R1),C'('              Insert (
         MVC   1(8,R1),TAGINVM         Move from user name
         DROP  R4                      TAG
         TRT   1(9,R1),BLANK           Look for end of userid
         MVI   0(R1),C')'              Insert )
         LA    R1,1(,R1)               -> end of msg
         LA    R0,LIST                 -> start of msg
         ST    R0,OLDMSGAD             Set msg ptr
         SR    R1,R0                   Compute length of msg
         STH   R1,LIST                 Set length of msg for PUTGET
         BR    R14                     Return
*
*-- Exit
*
XITNOT00 EQU   *
         SR    R0,R0               Set secondary RC=0;
         SR    R15,R15             Set RC=0; normal
         B     XITNOT
*
XITNOT04 EQU   *
         SR    R0,R0               Set secondary RC=0;
         LA    R15,4               Set RC=4;  END specified
         B     XITNOT
*
XITNOT08 EQU   *
         SR    R0,R0               Set secondary RC=0;
         LA    R15,8               Set RC=8;  PURGE specified
         B     XITNOT
*
XITNOT12 EQU   *
         LA    R15,12              Set RC=12; secondary is IKJPARS RC
         B     XITNOT
*
XITNOT16 EQU   *
         LA    R15,16              Set RC=16; secondary is PUTGET RC
*
XITNOT   EQU   *
         L     R13,4(,R13)         -> prev s.a.
         L     R14,12(,R13)        Load r14
         LM    R1,R12,24(R13)      Reload callers regs
         BR    R14                 Return with RCs in R0/R15
*
         LTORG
*                                                                       NJE00250
*                                                                       NJE00250
*********************
*  N J E D Y N      *               NJEDYN handles the various
*                   *               dynamic allocations required
*  Handle DYNALLOC  *               and their unallocations as well.
*                   *
*********************
*
         USING INMFIELD,R7          -> R7 at entry
*
NJEDYN   CSECT
         B     28(,R15)               BRANCH AROUND EYECATCHERS
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJEDYN'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
*
         STM   R14,R12,12(R13)         Save Regs                        NJE00050
         LR    R12,R15                 Base                             NJE00060
         USING NJEDYN,R12                                               NJE00070
         USING NJEWK,R10
         ST    R13,DYNSA+4             SAVE prv S.A. ADDR               NJE00080
         LA    R1,DYNSA                -> my save area
         ST    R1,8(,R13)              Plug it into prior SA
         LR    R13,R1
*
         MVC   LS99RB,CPS99RB          init THE S99RB
         LA    R1,LS99RB               -> S99RB
         USING S99RB,R1
         ST    R1,LS99PTR              Set parameter word
         OI    LS99PTR,X'80'           Set VL
         LA    R6,TXTPTRS              -> start of text unit list
         ST    R6,S99TXTPP             Put in S99RB
         DROP  R1                      S99RB
*
UNDYN    EQU   0                   00  unallocate DDNAME
DYNINMCP EQU   4                   04  Allocate INMCOPY dataset
DYNSYSIN EQU   8                   08  Allocate SYSIN for IEBCOPY
DYNSYSPR EQU   12                  0C  Allocate SYSPRINT for IEBCOPY
DYNFINAL EQU   16                  10  Allocate final dataset IEBCOPY
DYNSYSU3 EQU   20                  14  Allocate SYSUT3 IEBCOPY
DYNINDS  EQU   24                  18  Allocate INDATASET
DYNETSPL EQU   28                  1C  Allocate NETSPOOL
*
         LR    R5,R0                   Copy action code
         B     DYN000(R5)              Branch into table
*
DYN000   B     DYN010              00  Perform DDNAME Unallocation
         B     DYN100              04  Allocate INMCOPY dataset
         B     DYN200              08  Allocate SYSIN for IEBCOPY
         B     DYN300              0C  Allocate SYSPRINT for IEBCOPY
         B     DYN400              10  Allocate final dataset IEBCOPY
         B     DYN500              14  Allocate SYSUT3 IEBCOPY
         B     DYN600              18  Allocate INDATASET
         B     DYN700              1C  Allocate NETSPOOL
*
DYN010   EQU   *
         MVC   UTXT,UTXTD              Init text unit
         LA    R1,LS99RB               -> S99RB
         USING S99RB,R1
         MVI   S99VERB,S99VRBUN        Set verb code to unallocation
         DROP  R1                      S99RB
*
         LA    R0,UTXT                 -> UNALLOC DD text unit
         ST    R0,0(,R6)               Plug into ptr list
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Deallocate the DD
*
*-- Dataset created for INMCOPY INMR02 control record
*
*-- If there is no DSN, this is a temporary 'unloaded pds' dataset and
*-- no volser is used and can be allocated on a storage volume.
*
*   Equivalent JCL:
*   //SYS00000 DD DISP=(NEW,DELETE),UNIT=SYSDA,
*   //            SPACE=(blk,(pri,sec)),
*   //            DCB=(BLKSIZE=blk,LRECL=l,RECFM=f,DSORG=PS)
*
*-- If there is a DSN, then this is a final dataset, so use the
*-- dsname text unit and place it on the volser of choise.
*
*   Equivalent JCL:
*   //SYS00000 DD DISP=(NEW,CATLG),UNIT=SYSDA,
*   //            SPACE=(blk,(pri,sec)),
*   //            DCB=(BLKSIZE=blk,LRECL=l,RECFM=f,DSORG=PS),
*   //            DSN=dsname,VOL=SER=volser
*
DYN100   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT02,TXT02D
         MVC   TXT03,TXT03D
         MVC   TXT04,TXT04D
         MVC   TXT05,TXT05D
         MVC   TXT06,TXT06D
         MVC   TXT07,TXT07D
         MVC   TXT09,TXT09D
         MVC   TXT10,TXT10D
         MVC   TXT12,TXT12D
         MVC   TXT13,TXT13D
         MVC   TXT14,TXT14D
         MVC   TXT15,TXT15D
*
         LA    R0,TXT01                -> Return DDNAME text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP text unit 1
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT04                -> DISP text unit 2
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT12                -> BLKSIZE text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT05                -> BLKLEN text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT14                -> LRECL text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT15                -> RECFM text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT06                -> PRIMARY text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT07                -> SECONDARY text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT13                -> DSORG text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT10                -> UNIT text unit
         ST    R0,0(,R6)               Plug into ptr list
*
         CLC   DSNAME(2),=AL2(0)       Was there a DSN?
         BNE   DYN120                  Yes, plug DSN & VOL text unit
         MVI   TXT04+6,X'04'           No, its a temp; set DISP=,DELETE
*v223    B     DYN190                  Then skip DSN text unit     v200
         B     DYN130                  Process remaining txt units v223
*
DYN120   EQU   *
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT02                -> DSN text unit
         ST    R0,0(,R6)               Plug into ptr list
*
DYN130   EQU   *                                                   v223
         TM    FLAGS2,F2UNIT           Was UNIT specified?         v200
         BZ    DYN170                  No, leave default           v200
         MVC   TUNIT,USRUNIT           Set user's unit name        v200
         TM    FLAGS3,F3VOLSER         Did user specify VOLSER?    v200
         BO    DYN170                  Yes, use what he coded      v200
         TM    FLAGS4,F4VOLSER         Did user specify VOLSER?    v200
         BO    DYN170                  Yes, use what he coded      v200
         B     DYN190                  UNIT without VOLSER specif'dv200
*
DYN170   EQU   *                       Use specified VOL or GETVOL v200
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT09                -> VOLSER text unit
         ST    R0,0(,R6)               Plug into ptr list
*
DYN190   EQU   *                                                   v200
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- SYSIN for IEBCOPY
*
*   Equivalent JCL:
*   //SYS00000 DD DUMMY
*
*
DYN200   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT16,TXT16D
         LA    R0,TXT01                -> return DDNAME
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT16                -> DUMMY
         ST    R0,0(,R6)               Plug into ptr list
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- SYSPRINT for IEBCOPY
*
*   Equivalent JCL:
*   //SYS00000 DD SYSOUT=*,TERM=TS
*
DYN300   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT16,TXT16D
         MVC   TXT17,TXT17D
         MVC   TXT18,TXT18D
         LA    R0,TXT01                -> return DDNAME
         ST    R0,0(,R6)               Plug into ptr list
*
         TM    FLAGS3,F3QUIET          QUIET mode enabled?
         BO    DYN310                  Yes, use DUMMY
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT17                -> SYSOUT=*
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT18                -> TERM=TS
         ST    R0,0(,R6)               Plug into ptr list
         B     DYN320
*
DYN310   EQU   *
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT16                -> DUMMY
         ST    R0,0(,R6)               Plug into ptr list
*
DYN320   EQU   *
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- Final dataset that IEBCOPY will load
*
*   Equivalent JCL:
*   //SYS00000 DD DISP=(NEW,CATLG),UNIT=SYSDA,
*   //            SPACE=(blk,(pri,sec)),
*   //            DCB=(BLKSIZE=blk,LRECL=l,RECFM=f,DSORG=PO),
*   //            DSN=dsname,VOL=SER=volser
*
DYN400   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT02,TXT02D
         MVC   TXT03,TXT03D
         MVC   TXT04,TXT04D
         MVC   TXT05,TXT05D
         MVC   TXT06,TXT06D
         MVC   TXT07,TXT07D
         MVC   TXT08,TXT08D
         MVC   TXT09,TXT09D
         MVC   TXT10,TXT10D
         MVC   TXT12,TXT12D
         MVC   TXT13,TXT13D
         MVC   TXT14,TXT14D
         MVC   TXT15,TXT15D
*
         LA    R0,TXT01                -> Return DDNAME text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP text unit 1
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT04                -> DISP text unit 2
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT12                -> BLKSIZE text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT05                -> BLKLEN text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT14                -> LRECL text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT15                -> RECFM text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT06                -> PRIMARY text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT07                -> SECONDARY text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT08                -> DIRECTORY BLOCKS text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT13                -> DSORG text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT02                -> DSN text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot       v200
         LA    R0,TXT10                -> UNIT text unit           v200
         ST    R0,0(,R6)               Plug into ptr list          v200
*
         TM    FLAGS2,F2UNIT           Was UNIT specified?         v200
         BZ    DYN470                  No, leave default           v200
         MVC   TUNIT,USRUNIT           Set user's unit name        v200
         TM    FLAGS3,F3VOLSER         Did user specify VOLSER?    v200
         BO    DYN470                  Yes, use what he coded      v200
         TM    FLAGS4,F4VOLSER         Did user specify VOLSER?    v200
         BO    DYN470                  Yes, use what he coded      v223
         B     DYN490                  UNIT without VOLSER specif'dv200
*
DYN470   EQU   *                       Use specified VOL or GETVOL v200
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT09                -> VOLSER text unit
         ST    R0,0(,R6)               Plug into ptr list
*
DYN490   EQU   *                                                   v200
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- SYSUT3 for IEBCOPY
*
*   Equivalent JCL:
*   //SYS00000 DD DISP=(NEW,DELETE),UNIT=SYSDA,
*   //            SPACE=(CYL,5)
*
DYN500   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT03,TXT03D            DISP 1
         MVC   TXT04,TXT04D            DISP 2
         MVC   TXT06,TXT06D            PRIME
         MVC   TXT10,TXT10D            UNIT
         MVC   TXT19,TXT19D            CYL
*
         MVI   TXT04+6,X'04'           Adjust to DISP=,DELETE
         MVC   TXT06+6(3),=XL3'05'     5 cylinders
*
         LA    R0,TXT01                -> return DDNAME
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP=NEW
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT04                -> DISP=,DELETE
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT06                -> Primary space
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT10                -> UNIT
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT19                -> SPACE CYL
         ST    R0,0(,R6)               Plug into ptr list
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- Dataset INDATASET
*
*   Equivalent JCL:
*   //SYS00000 DD DISP=SHR,DSNAME=indataset
*
DYN600   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT02,TXT02D
         MVC   TXT03,TXT03D
         MVC   TXT13,TXT13D
*
         MVI   TXT03+6,X'08'           set DISP=SHR
         MVC   TXT13(2),=Y(DALRTORG)   set RETURN DSORG
*
         LA    R0,TXT01                -> return DDNAME
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP=SHR
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT13                -> DSORG
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT02                -> DSNAME
         ST    R0,0(,R6)               Plug into ptr list
*
DYN610   EQU   *
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- Dataset NETSPOOL
*
*   Equivalent JCL:
*   //NETSPOOL DD DISP=SHR,DSNAME=NJE38.NETSPOOL
*
*
DYN700   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT02,TXT02D
         MVC   TXT03,TXT03D
*
         MVC   TXT01(2),=Y(DALDDNAM)   Use fixed DD
         MVI   TXT03+6,X'08'           set DISP=SHR
*
         LA    R0,TXT01                -> DDNAME
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP=SHR
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT02                -> DSNAME
         ST    R0,0(,R6)               Plug into ptr list
*
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- Allocate the dataset
*
DYN900   EQU   *
         LA    R1,LS99RB               -> S99RB
         USING S99RB,R1
         OI    S99FLAG1,S99NOCNV        FORCE NEW ALLOCATION
         DROP  R1
         LA    R1,LS99PTR               POINTER TO S99 PTR
         SVC   99                       ISSUE DYNALLOC
         LTR   R15,R15                  Any errors?
         BZ    XITDYN00                 No
*
         LA    R1,LS99RB
         USING S99RB,R1
         UNPK  TWRK(9),S99ERROR(5)      Add zones to error code
         L     R4,S99ERROR              Error code in R4 for later v200
         DROP  R1
         TR    TWRK(8),HEXTRAN-240
         CLI   TWRK+1,C'7'              Class 7 error code?
         BNE   ERR012                   No
         LA    R1,DYNINMCP              Code for the INMCOPY dataset?
         CR    R1,R5                    Was alloc for DYNINMCP?
         BE    ERR027                   Yes, dataset exists
         LA    R1,DYNFINAL              Code for the final dataset?
         CR    R1,R5                    Was alloc for DYNFINAL?
         BE    ERR027                   Yes, dataset exists
         LA    R1,DYNINDS               Code for the INDATASET?
         CR    R1,R5                    Was alloc for DYNINDS?
         BE    ERR031                   Yes, dataset does not exist
*
ERR012   EQU   *
         MVC   LIST(4+L'MSG012T),MSG012 Dyn alloc failure msg
         MVC   LIST+21(8),TWRK          Error codes to line
         MVC   LIST+35(44),TDSNAME      Move DSNAME
         LA    R2,LIST                  -> msg
         BAL   R14,PUTLINE              Display it
         CLM   R4,12,=X'0218'           volume conflict/invalid?   v200
         BE    ERR033                   Yes                        v200
         CLM   R4,12,=X'021C'           Unit undefined?            v200
         BE    ERR034                   Yes                        v200
         B     XITDYN08                 General allocation failure
*
ERR027   EQU   *
         MVC   LIST,BLANKS
         MVC   LIST+4(9),=C'Dataset '''
         MVC   LIST+13(44),TDSNAME Move name
         TRT   LIST+13(45),BLANK   Look for end of name
         MVI   0(R1),C''''         Close apost
         LA    R1,1(,R1)           Skip apost
         MVC   0(L'MSG027T,R1),MSG027T  Move rest of msg
         LA    R1,L'MSG027T(,R1)   point to end
         XC    LIST(4),LIST        Clear RDW area
         LA    R2,LIST             -> start of RDW+msg
         SR    R1,R2               Compute total length
         STH   R1,LIST             Plug RDW
         BAL   R14,PUTLINE         Inform user
         B     XITDYN04            And exit with dataset exists
*
ERR031   EQU   *
         MVC   LIST,BLANKS
         MVC   LIST+4(9),=C'Dataset '''
         MVC   LIST+13(44),TDSNAME Move name
         TRT   LIST+13(45),BLANK   Look for end of name
         MVI   0(R1),C''''         Close apost
         LA    R1,1(,R1)           Skip apost
         MVC   0(L'MSG031T,R1),MSG031T  Move rest of msg
         LA    R1,L'MSG031T(,R1)   point to end
         XC    LIST(4),LIST        Clear RDW area
         LA    R2,LIST             -> start of RDW+msg
         SR    R1,R2               Compute total length
         STH   R1,LIST             Plug RDW
         BAL   R14,PUTLINE         Inform user
         B     XITDYN04            And exit with dataset doesnt exist
*
ERR033   EQU   *                                                   v200
         LA    R2,MSG033           -> msg (inv unit/volser combo)  v200
         BAL   R14,PUTLINE              Display it                 v200
         B     XITDYN08                                            v200
*
ERR034   EQU   *                                                   v200
         LA    R2,MSG034           -> msg (undefined unit)         v200
         BAL   R14,PUTLINE              Display it                 v200
         B     XITDYN08                                            v200
*
*
*-- Exit
*
XITDYN00 EQU   *
         SR    R15,R15             Set RC=0;  alloc/dealloc ok
         B     XITDYN
*
XITDYN04 EQU   *
         LA    R15,4               Set RC=4;  Exit for special action
         B     XITDYN
*
XITDYN08 EQU   *
         LA    R15,8               Set RC=8;  allocation error
*
XITDYN   EQU   *
         L     R13,4(,R13)         -> prev s.a.
         ST    R15,16(,R13)        Set RC
         LM    R14,R12,12(R13)     Reload callers regs
         BR    R14                 Return with RC
*
         LTORG
         DROP  R7                  INMFIELD
*
*
*
*-- Text unit skeletons
*
*-- Note:  EXPDT is included for completeness but is not used.
*
*
*
TXT01D   DC    Y(DALRTDDN),AL2(1),AL2(8)          RETURN DDNAME
TXT02D   DC    Y(DALDSNAM),AL2(1),AL2(44)         DSNAME
TXT03D   DC    Y(DALSTATS),AL2(1),AL2(1),X'04'    DISP=(NEW,)
TXT04D   DC    Y(DALNDISP),AL2(1),AL2(1),X'02'    DISP=(,CATLG)
TXT05D   DC    Y(DALBLKLN),AL2(1),AL2(3)          BLK TEXT KEY, BLKLEN
TXT06D   DC    Y(DALPRIME),AL2(1),AL2(3)          PRIMARY SPACE UNITS
TXT07D   DC    Y(DALSECND),AL2(1),AL2(3)          SECONDARY SPACE UNITS
TXT08D   DC    Y(DALDIR),AL2(1),AL2(3)            DIRECTORY BLOCKS
TXT09D   DC    Y(DALVLSER),AL2(1),AL2(6)          VOLSER
TXT10D   DC    Y(DALUNIT),AL2(1),AL2(8),CL8'SYSDA'  UNIT default   v200
TXT11D   DC    Y(DALEXPDT),AL2(1),AL2(5)          EXPDT C'YYDDD'
TXT12D   DC    Y(DALBLKSZ),AL2(1),AL2(2)          BLKSIZE
TXT13D   DC    Y(DALDSORG),AL2(1),AL2(2)          DSORG
TXT14D   DC    Y(DALLRECL),AL2(1),AL2(2)          LRECL
TXT15D   DC    Y(DALRECFM),AL2(1),AL2(1)          RECFM
TXT16D   DC    Y(DALDUMMY),AL2(0)                 DUMMY
TXT17D   DC    Y(DALSYSOU),AL2(0)                 SYSOUT
TXT18D   DC    Y(DALTERM),AL2(0)                  TERM
TXT19D   DC    Y(DALCYL),AL2(0)                   CYLINDER
TXT20D   DC    Y(DALCLOSE),AL2(0)                 FREE=CLOSE
*
UTXTD    DC    Y(DUNDDNAM),AL2(1),AL2(8)          DD for deallocation
*
         DS    0F
CPS99RB  DS    0XL20                   DEFINE INITIAL S99RB
         DC    AL1(20)                 LENGTH OF REQ BLOCK
         DC    AL1(1)                  VERB CODE:  ALLOCATION
         DC    X'20'                   FLAGS:  NO MOUNTS,OFFLINE VOLS
         DC    X'00'                   FLAGS
         DC    AL2(0)                  ERROR REASON CODE
         DC    AL2(0)                  INFO REASON CODE
         DC    A(0)                    ADDR OF TEXT PTRS
         DC    A(0)                    ADDR OF RBX
         DC    AL4(0)                  MORE FLAGS
*                                                                       NJE00250
*                                                                       NJE00250
*********************
*  N J E N E T      *               NJENET determines if NETDATA
*                   *               exists in a spool file and
*  Examine NETDATA  *               examines the INMR02 control
*                   *               record for attributes
*********************
*
NJENET   CSECT
         B     28(,R15)               BRANCH AROUND EYECATCHERS
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJENET'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
*
         STM   R14,R12,12(R13)         Save Regs                        NJE00050
         LR    R12,R15                 Base                             NJE00060
         USING NJENET,R12                                               NJE00070
         USING NJEWK,R10
         ST    R13,NETSA+4             SAVE prv S.A. ADDR               NJE00080
         LA    R1,NETSA                -> my save area
         ST    R1,8(,R13)              Plug it into prior SA
         LR    R13,R1
*
         LR    R15,R0                  Copy action code
         B     FUNC000(R15)            Branch into table
*
FUNC000  B     PINIT000            00  Process initial ctl records
         B     PDATA000            04  Process netdata records
         B     PFLAT000            08  Process flat records
*
*-- Find INMR01 record                                                  NET00060
*                                                                       NET00060
PINIT000 EQU   *
         LA    R0,2                    # of bytes to get                NET00070
         BAL   R14,GETBYTES            Get length and desc of segment   NET00080
         MVC   CTL,1(R1)               Save copy of descriptor byte
*                                                                       NET00090
         CLI   CTL,X'E0'               Valid 1st control rec indic?v200 NET00100
         BE    PINIT010                Could be ok                 v200 NET00110
         CLI   CTL,X'A0'               Valid 1st control rec indic?v200 NET00100
         BNE   XITNET04                No, its not NETDATA         v200 NET00110
*                                                                       NET00120
PINIT010 EQU   *                                                   v200
         L     R2,GBRPS                -> phys record position     v200
         CLC   0(6,R2),INMR01          Peek ahead. INMR01?         v200
         BNE   XITNET04                No, its not NETDATA         v200
*
         SR    R0,R0                                                    NET00130
         IC    R0,0(,R1)               Get segment length byte          NET00140
         S     R0,=F'2'                Less 2 we already retrieved      NET00150
         LR    R3,R0                   Copy length of control record    NET00300
         BAL   R14,GETBYTES            Get control record               NET00160
*                                                                       NET00170
         CLC   0(6,R1),INMR01          NETDATA?                         NET00180
         BNE   XITNET04                Not NETDATA                      NET00190
*
         LA    R15,6                   Len of "INMR01"                  NET00360
         AR    R1,R15                  Skip over that field             NET00370
         LA    R9,INMF01               -> area to hold INMR01 fields
         USING INMFIELD,R9
         BAL   R14,CTL000              Go parse control record
         OI    FLAGS1,F1INMR01         Indicate fields processed
*
*-- Find INMR02 record                                                  NET00060
*                                                                       NET00200
FINMR02  EQU   *
         LA    R0,2                    # of bytes to get                NET00210
         BAL   R14,GETBYTES            Get length and desc of segment   NET00220
         MVC   CTL,1(R1)               Save copy of descriptor byte
*                                                                       NET00090
         LA    R0,CODE1                Control record not indicated
         TM    CTL,X'20'               Is this a control record?        NET00100
         BZ    XITNET08                No, invalid NETDATA              NET00110
*                                                                       NET00260
         SR    R0,R0                                                    NET00270
         IC    R0,0(,R1)               Get segment length byte          NET00280
         S     R0,=F'2'                Less 2 we already retrieved      NET00290
         LR    R3,R0                   Copy length of control record    NET00300
         BAL   R14,GETBYTES            Get control record               NET00310
*                                                                       NET00320
         LA    R0,CODE2                INMR02 record not detected
         CLC   0(6,R1),INMR02          NETDATA?                         NET00330
         BNE   XITNET08                invalid NETDATA                  NET00190
*                                                                       NET00350
         LA    R15,10                  Len of "INMR02"+file number word NET00360
         AR    R1,R15                  Skip over those fields           NET00370
         LA    R9,INMF02A              -> area to hold INMR02 fields
         BAL   R14,CTL000              Go parse control record
         TM    FLAGS2,F2TERM           Was a TERM text unit key found?
         BO    XITNET20                Y, unsupported
         OI    FLAGS1,F1INMR2A         Indicate fields processed
*
*-- Find INMR02 or INMR03 record                                        NET00060
*                                                                       NET00200
         LA    R0,2                    # of bytes to get                NET00210
         BAL   R14,GETBYTES            Get length and desc of segment   NET00220
         MVC   CTL,1(R1)               Save copy of descriptor byte
*                                                                       NET00090
         LA    R0,CODE3                Control record not indicated
         TM    CTL,X'20'               Is this a control record?        NET00100
         BZ    XITNET08                No, invalid NETDATA              NET00110
*                                                                       NET00260
         SR    R0,R0                                                    NET00270
         IC    R0,0(,R1)               Get segment length byte          NET00280
         S     R0,=F'2'                Less 2 we already retrieved      NET00290
         LR    R3,R0                   Copy length of control record    NET00300
         BAL   R14,GETBYTES            Get control record               NET00310
*                                                                       NET00320
         CLC   0(6,R1),INMR03          Is it INMR03?                    NET00330
         BE    IR03                    Yes, go there                    NET00190
         LA    R0,CODE4                INMR02 record not detected
         CLC   0(6,R1),INMR02          Is it INMR02?                    NET00330
         BNE   XITNET08                Something wrong; inval NETDATA   NET00190
*                                                                       NET00350
         LA    R15,10                  Len of "INMR02"+file number word NET00360
         AR    R1,R15                  Skip over those fields           NET00370
         LA    R9,INMF02B              -> area to hold INMR02 fields
         BAL   R14,CTL000              Go parse control record
         TM    FLAGS2,F2TERM           Was a TERM text unit key found?
         BO    XITNET20                Y, unsupported
         OI    FLAGS1,F1INMR2B         Indicate fields processed
*
*-- Find INMR03 record                                                  NET00060
*                                                                       NET00200
FINMR03  EQU   *
         LA    R0,2                    # of bytes to get                NET00210
         BAL   R14,GETBYTES            Get length and desc of segment   NET00220
         MVC   CTL,1(R1)               Save copy of descriptor byte
*                                                                       NET00090
         LA    R0,CODE5                INMR03 ctl rec not indicated
         TM    CTL,X'20'               Is this a control record?        NET00100
         BZ    XITNET08                No, invalid NETDATA              NET00110
*                                                                       NET00260
         SR    R0,R0                                                    NET00270
         IC    R0,0(,R1)               Get segment length byte          NET00280
         S     R0,=F'2'                Less 2 we already retrieved      NET00290
         LR    R3,R0                   Copy length of control record    NET00300
         BAL   R14,GETBYTES            Get control record               NET00310
*                                                                       NET00320
         LA    R0,CODE6                INMR03 record not detected
         CLC   0(6,R1),INMR03          Is it INMR03?                    NET00330
         BNE   XITNET08                Something wrong; invalid NETDATA NET00190
*                                                                       NET00350
IR03     EQU   *
         LA    R15,6                   Len of "INMR03"                  NET00360
         AR    R1,R15                  Skip over those fields           NET00370
         LA    R9,INMF03               -> area to hold INMR02 fields
         BAL   R14,CTL000              Go parse control record
         OI    FLAGS1,F1INMR03         Indicate fields processed
         B     XITNET00                Done
*                                                                       NET00380
*-- Parse the text unit keys from a control record                      NET00380
*                                                                       NET00380
*-- Entry:  R3 = length of entire control record                        NET00380
*--         R15= length of INMRxx header fields to skip over
*-- Exit:   Keys identified are parsed an in their respective fields    NET00380
*                                                                       NET00380
CTL000   EQU   *                                                        NET00390
         ST    R14,SV14CTL             Save return addr
*
CTL010   EQU   *                                                        NET00390
         LA    R4,CTL010               Where to return with new segmnt
         SR    R3,R15                  Reduce remaining length          NET00400
         BNP   CTL070                  Done with control record segmnt  NET00410
         LA    R7,INMKEYS              -> text unit keys table
*                                                                       NET00420
*-- Look for supported keys                                             NET00430
*                                                                       NET00440
CTL020   EQU   *                                                        NET00390
         LA    R0,CODE7                Inv/unrecognized NETDATA key
         CLI   0(R7),X'FF'             End of table?
         BE    XITNET08                Invalid NETDATA key
*
         CLC   0(2,R1),0(R7)           Look for matching key            NET00450
         BE    CTL030                  Got one                          NET00460
         LA    R7,KEYLEN(,R7)          Bump to next in table
         B     CTL020                  Keep searching
*
CTL030   EQU   *                                                        NET00390
         ICM   R15,15,2(R7)            -> supporting rtn for key
         BNZR  R15                     Go there if rtn available
*                                                                       NET00610
*-- Skip over and ignore unsupported/unrecognized keys                  NET00620
*                                                                       NET00630
CTL050   EQU   *
         LA    R1,2(,R1)               Skip over unrecognized key       NET00640
         LA    R15,2                   Remaining length adjust          NET00650
         SR    R0,R0                   Clear for IC                     NET00660
         ICM   R0,3,0(R1)              Get # value                      NET00670
         LA    R1,2(,R1)               Skip over # value                NET00680
         LA    R15,2(,R15)             Remaining length adjust          NET00690
         BZ    CTL010                  # was 0; no lengths              NET00700
*
         LA    R4,CTL060               Where to return with new segmnt
         SR    R3,R15                  Reduce remaining length          NET00400
         BNP   CTL070                  Done with control record segmnt  NET00410
*                                                                       NET00720
CTL060   EQU   *                                                        NET00730
         SR    R14,R14                 Clear for ICM                    NET00710
         ICM   R14,3,0(R1)             Get length field                 NET00740
         LA    R1,2(R14,R1)            Skip over length and data        NET00750
         LA    R15,2(R14,R15)          Remaining length adjust          NET00760
         BCT   R0,CTL060               Do next len/data field pair      NET00770
         B     CTL010                  Resume                           NET00780
*                                                                       NET00720
*-- Here at end of segment or entire control record.                    NET00720
*-- We could also be here in the middle of a key (like INMMEMBR) and    NET00720
*-- we need to return to the right place after getting the next
*-- segment to continue on.
*                                                                       NET00720
CTL070   EQU   *                                                        NET00730
         TM    CTL,X'40'               Was that the final segment?
         BO    CTL090                  Yes, done with control record
*
*-- We need another control record segment
*
         ST    R0,SVR0CTL              Save # value for keys in progres
         LA    R0,2                    # of bytes to get                NET00070
         BAL   R14,GETBYTES            Get length and desc of segment   NET00080
         MVC   CTL,1(R1)               Save copy of descriptor byte
*                                                                       NET00090
         LA    R0,CODE8                Ctl rec segment not detected
         TM    CTL,X'20'               Is this a control record?        NET00100
         BZ    XITNET08                Bad...something wrong            NET00110
*                                                                       NET00120
         SR    R0,R0                                                    NET00130
         IC    R0,0(,R1)               Get segment length byte          NET00140
         S     R0,=F'2'                Less 2 we already retrieved      NET00150
         LR    R3,R0                   Copy length of ctl segment       NET00300
         BAL   R14,GETBYTES            Get control record segment       NET00160
         L     R0,SVR0CTL              Restore # value of the key
         SR    R15,R15                 Clear length adjustment
         BR    R4                      Return to CTL010 or CTL060
*                                                                       NET00720
CTL090   EQU   *                                                        NET00730
         L     R14,SV14CTL             Load return addr
         BR    R14                     Done with control record
*                                                                       NET00790
*-- Handle keys we dont support.                                        NET00800
*-- We look for INMTERM in order to bail out if present.
*-- This is generated by modern TRANSMIT with MSG.
*
TRM000   EQU   *
         OI    FLAGS2,F2TERM           Indicate INMTERM discovered
         B     CTL050                  Ignore the text unit key
*
*-- Handle keys we support, as well as those that we will capture       NET00800
*-- a value for but not do anything with it (example: creation date).
*                                                                       NET00810
*- Utility name                                                         NET00820
UTL000   EQU   *                       Get utility name                 NET00830
         MVC   UTLNAME+2,BLANKS         Init receiving field            NET00840
         LA    R6,UTLNAME              -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*                                                                       NET00870
*- File size                                                            NET00880
FSZ000   EQU   *                       File size                        NET00890
         LA    R6,FILESIZE             -> receiving field               NET00900
         BAL   R14,KEY000              Go handle the key                NET00910
         BAL   R14,ADJ000              Right justify the value          NET00910
         B     CTL010                  Scan for next key
*                                                                       NET00920
*- DSORG                                                                NET00930
DSG000   EQU   *                       DSORG                            NET00940
         LA    R6,DSORG                -> receiving field               NET00950
         BAL   R14,KEY000              Go handle the key                NET00960
         B     CTL010                  Scan for next key
*- BLKSIZE                                                              NET00970
BLK000   EQU   *                       BLKSIZE                          NET00980
         LA    R6,BLKSIZE              -> receiving field               NET00990
         BAL   R14,KEY000              Go handle the key                NET01000
         BAL   R14,ADJ000              Right justify the value          NET00910
         B     CTL010                  Scan for next key
*                                                                       NET01010
*- LRECL                                                                NET01020
LRL000   EQU   *                       LRECL                            NET01030
         LA    R6,LRECL                -> receiving field               NET01040
         BAL   R14,KEY000              Go handle the key                NET01050
         BAL   R14,ADJ000              Right justify the value          NET00910
         B     CTL010                  Scan for next key
*                                                                       NET01060
*- RECFM                                                                NET01070
RFM000   EQU   *                       RECFM                            NET01080
         LA    R6,RECFM                -> receiving field               NET01090
         BAL   R14,KEY000              Go handle the key                NET01100
         B     CTL010                  Scan for next key
*                                                                       NET00870
*- # directory blocks                                                   NET00880
DIR000   EQU   *                       File size                        NET00890
         LA    R6,DIRBLKS              -> receiving field               NET00900
         BAL   R14,KEY000              Go handle the key                NET00910
         BAL   R14,ADJ000              Right justify the value          NET00910
         B     CTL010                  Scan for next key
*                                                                       NET01110
*- FFM                                                                  NET01120
FFM000   EQU   *                       File mode number                 NET01130
         LA    R6,FFM                  -> receiving field               NET01140
         BAL   R14,KEY000              Go handle the key                NET01150
         B     CTL010                  Scan for next key
*
*- Origin timestamp                                                     NET00820
FTM000   EQU   *                                                        NET00830
         MVC   FTIME+2,BLANKS          Init receiving field             NET00840
         LA    R6,FTIME                -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- Origin node                                                          NET00820
FND000   EQU   *                       Get origin node                  NET00830
         MVC   FNODE+2,BLANKS          Init receiving field             NET00840
         LA    R6,FNODE                -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- Origin userid                                                        NET00820
FUS000   EQU   *                       Get origin userid                NET00830
         MVC   FUSER+2,BLANKS          Init receiving field             NET00840
         LA    R6,FUSER                -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- To node                                                              NET00820
TND000   EQU   *                       Get destination node             NET00830
         MVC   TNODE+2,BLANKS          Init receiving field             NET00840
         LA    R6,TNODE                -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- To userid                                                            NET00820
TUS000   EQU   *                       Get destination userid           NET00830
         MVC   TUSER+2,BLANKS          Init receiving field             NET00840
         LA    R6,TUSER                -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- Version                                                              NET00820
VER000   EQU   *                       Get Version info                 NET00830
         MVC   FVERS+2,BLANKS          Init receiving field             NET00840
         LA    R6,FVERS                -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         BAL   R14,ADJ000              Right justify the value          NET00910
         B     CTL010                  Scan for next key
*
*- Creation date                                                        NET00820
CRE000   EQU   *                                                        NET00830
         MVC   CREATE+2,BLANKS         Init receiving field             NET00840
         LA    R6,CREATE               -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- DDNAME                                                               NET00820
DDN000   EQU   *                                                        NET00830
         MVC   DDNAME+2,BLANKS         Init receiving field             NET00840
         LA    R6,DDNAME               -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- Extended attribute                                                   NET00820
ATR000   EQU   *                                                        NET00830
         LA    R6,EATTR                -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- RECEIVE error code                                                   NET00820
ECD000   EQU   *                                                        NET00830
         LA    R6,ERRCD                -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- Expiration date                                                      NET00820
EXP000   EQU   *                                                        NET00830
         MVC   EXPDT+2,BLANKS          Init receiving field             NET00840
         LA    R6,EXPDT                -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- Last changed date                                                    NET00820
LCH000   EQU   *                                                        NET00830
         MVC   LCHG+2,BLANKS           Init receiving field             NET00840
         LA    R6,LCHG                 -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*
*- Last referenced date                                                 NET00820
LRF000   EQU   *                                                        NET00830
         MVC   LREF+2,BLANKS           Init receiving field             NET00840
         LA    R6,LREF                 -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*                                                                       NET00870
*- Size in megabytes                                                    NET00880
LSZ000   EQU   *                       File size in MB                  NET00890
         LA    R6,LSIZE                -> receiving field               NET00900
         BAL   R14,KEY000              Go handle the key                NET00910
         B     CTL010                  Scan for next key
*                                                                       NET00870
*- Number of files                                                      NET00880
NMF000   EQU   *                       File size in MB                  NET00890
         LA    R6,NUMF                 -> receiving field               NET00900
         BAL   R14,KEY000              Go handle the key                NET00910
         BAL   R14,ADJ000              Right justify the value          NET00910
         B     CTL010                  Scan for next key
*                                                                       NET00870
*- Record count                                                         NET00880
RCT000   EQU   *                                                        NET00890
         LA    R6,RECCT                -> receiving field               NET00900
         BAL   R14,KEY000              Go handle the key                NET00910
         BAL   R14,ADJ000              Right justify the value          NET00910
         B     CTL010                  Scan for next key
*                                                                       NET00870
*- Secondary space                                                      NET00880
SEC000   EQU   *                                                        NET00890
         LA    R6,SECND                -> receiving field               NET00900
         BAL   R14,KEY000              Go handle the key                NET00910
         B     CTL010                  Scan for next key
*
*- Destination timestamp                                                NET00820
TTM000   EQU   *                                                        NET00830
         MVC   TTIME+2,BLANKS          Init receiving field             NET00840
         LA    R6,TTIME                -> receiving field               NET00850
         BAL   R14,KEY000              Go handle the key                NET00860
         B     CTL010                  Scan for next key
*                                                                       NET00870
*- Dataset Type                                                         NET00880
TYP000   EQU   *                       Data set type                    NET00890
         LA    R6,DSTYPE               -> receiving field               NET00900
         BAL   R14,KEY000              Go handle the key                NET00910
         B     CTL010                  Scan for next key
*                                                                       NET01160
*                                                                       NET01160
*- DSNAME                                                               NET01170
DSN000   EQU   *                       DSNAME                           NET01180
         MVC   DSNAME+2,BLANKS         Init receiving field             NET01190
         LA    R6,DSNAME+2             -> receiving field               NET01200
         LA    R1,2(,R1)               Skip over key                    NET01210
         LA    R15,2                   Remaining length adjust          NET01220
         SR    R0,R0                   Clear for IC                     NET01230
         ICM   R0,3,0(R1)              Get # value                      NET01240
         LA    R1,2(,R1)               Skip over # value                NET01250
         LA    R15,2(,R15)             Remaining length adjust          NET01260
         BZ    CTL010                  # was 0; no lengths              NET01270
         SR    R14,R14                 Clear for ICM                    NET01280
*                                                                       NET01290
DSN020   EQU   *                                                        NET01300
         ICM   R14,3,0(R1)             Get length field                 NET01310
         BCT   R14,DSN030              Adjust for execute               NET01320
         MVC   0(0,R6),2(R1)           executed instr                   NET01330
DSN030   EX    R14,*-6                 Move name to receiving field     NET01340
         LA    R1,3(R14,R1)            Skip over length and data        NET01350
         LA    R15,3(R14,R15)          Remaining length adjust          NET01360
         LA    R6,1(R14,R6)            Bump to next qualifier area      NET01370
         MVI   0(R6),C'.'              Add qualifier dot
         LA    R6,1(,R6)               -> next qualifier area
         BCT   R0,DSN020               Do next len/data field pair      NET01380
         BCTR  R6,0                    -> last byte of DSNAME           NET01390
         MVI   0(R6),C' '              Remove trailing dot
         BCTR  R6,0                    -> prior to trailing '.'         NET01390
         LA    R0,DSNAME+2             -> start of DSNAME               NET01400
         SR    R6,R0                   Compute final DSN length         NET01410
         STCM  R6,3,DSNAME             Save it                          NET01420
         B     CTL010                  get next key                     NET01430
*                                                                       NET01440
*-- Common routine to break part key/#/len/data elements that have #=1  NET01450
*                                                                       NET01460
KEY000   EQU   *                                                        NET01470
         LA    R1,4(,R1)               Skip over key, #                 NET01480
         LA    R15,4                   Remaining length accum           NET01490
         SR    R5,R5                   Clear for IC                     NET01500
         ICM   R5,3,0(R1)              Get length of name               NET01510
         STCM  R5,3,0(R6)              Store actual len in result fld
         BZR   R14                     If no length, done with key
         BCT   R5,KEY010               Adjust for execute               NET01520
         MVC   2(0,R6),2(R1)           executed instr                   NET01530
KEY010   EX    R5,*-6                  Move name to receiving field     NET01540
         LA    R1,3(R5,R1)             -> next text unit key            NET01550
         LA    R15,3(R5,R15)           Accum length adjustment          NET01560
         BR    R14                     Return                           NET01570
*
*-- Common routine right justify numeric fields of numeric text units   NET01450
*                                                                       NET01460
ADJ000   EQU   *
         LA    R8,8                    Max length of value
         LH    R0,0(,R6)               Get length from NETDATA key
         SR    R8,R0                   Compute # bytes of shift
         BZR   R14                     No justification required
         SLA   R8,3                    Turn # bytes into # bits
         LM    R4,R5,2(R6)             Get numeric field
         SRDL  R4,0(R8)                Right justify the number
         STM   R4,R5,2(R6)             Put back justified numeric value
         BR    R14
*
         DROP  R9                      INMFIELD
*
*
*-- Process data records
*
*-- NOTE!  We are using PUT LOCATE mode here, which offers the
*--        flexibility to accomodate RECFM=VS and VBS records when
*--        combined with DCB=BFTEK=A.  This can be confusing looking
*--        as it seems the PUT is issued and then the record is built.
*--        However, the PUT is actually writing the previous record
*--        and the last record is written by CLOSE, all per the IBM
*--        data management specification.
*
*-- NOTE!  RECFM=U processing requires the length of the record
*--        be stored in DCBLRECL prior to the PUT LOCATE being issued.
*--        But we don't know the length of the record yet, because it
*--        is coming in from the NETDATA in segments.  So, we have to
*--        unfortunately use a separate buffer to accumulate the
*--        segments and when complete obtain the total length to
*--        store into DCBLRECL.  Then we can issue the PUT.  Then
*--        we have to move the data from our segment accumulation
*--        buffer into the PUT LOCATE buffer. Note though, that
*--        if we used PUT MOVE for RECFM=U, the system would
*--        move our data out of the segment buffer; so either way
*--        the data is moved an extra time.
*
PDATA000 EQU   *
         LA    R0,2                    # of bytes to get                NET00210
         BAL   R14,GETBYTES            Get length and desc of segment   NET00220
*                                                                       NET00230
         TM    1(R1),X'20'             Is this a control record?        NET00240
         BO    PDATA100                Yes                              NET00110
*
         MVC   CTL,1(R1)               Save copy of descriptor byte
         SR    R0,R0                                                    NET00130
         IC    R0,0(,R1)               Get segment length byte          NET00140
         S     R0,=F'2'                Less 2 we already retrieved      NET00150
         LR    R3,R0                   Copy length of segment           NET00300
         BAL   R14,GETBYTES            Get a segment                    NET00160
         LR    R4,R1                   Copy segment ptr
*
*-- Determine type of record segment
*
         TM    CTL,X'C0'           C0  Complete record?
         BO    CMP000                  Yes
         TM    CTL,X'80'           80  1st record of segment?
         BO    FST000                  Yes
         TM    CTL,X'40'           40  last record of segment?
         BO    LST000                  Yes
*
*-- Middle segment
*
MID000   EQU   *                   00  Handle middle segment
         L     R1,RBPOS                -> next available buffer byte
         LR    R0,R1                   Copy next available ptr     v222
         S     R0,RBUFF                Compute len used so far     v222
         AR    R0,R3                   Add len of next segment     v222
         CH    R0,NEWDS+(DCBLRECL-IHADCB) will segment fit in buff?v222
         BH    XITNET24                No. record too large        v222
         BCTR  R3,0                    Adjust for execute
         EX    R3,MVCSEG               Move segement data
         LA    R1,1(R3,R1)             -> next available byte
         ST    R1,RBPOS                Save record position
         B     PDATA000                Go get some more
*
*-- Complete segment (an entire record)
*
CMP000   EQU   *
         TM    TRECFM,X'C0'            Using undefined format?
         BO    CMPU100                 Yes
*
         PUT   NEWDS                   Write R1 buffer and get new one
*
         TM    TRECFM,X'40'            Using variable format?
         BO    CMP010                  Yes
         BCTR  R3,0                    Adjust for execute
         EX    R3,MVCSEG               Move segment data
         B     PDATA000                Go get some more
*
CMP010   EQU   *
         LA    R0,4(,R3)               Copy record length + 4
         SLL   R0,16                   Make RDW = LLZZ
         STCM  R0,15,0(R1)             Plug in RDW
         LA    R1,4(,R1)               Skip over RDW
         BCTR  R3,0                    Adjust for execute
         EX    R3,MVCSEG               Move segment data
         B     PDATA000                Go get some more
*
CMPU100  EQU   *                    ** Here if RECFM=U only
         STH   R3,NEWDS+(DCBLRECL-IHADCB) Set len of output recrd
         PUT   NEWDS                   Write R1 buffer and get new one
         BCTR  R3,0                    Adjust for execute
         EX    R3,MVCSEG               Move segment data
         B     PDATA000                Go get some more
*
MVCSEG   MVC   0(0,R1),0(R4)           executed instr
*
*-- First segment of a record
*
FST000   EQU   *                       Handle first segment
         TM    TRECFM,X'C0'            Using undefined format?
         BO    FSTU100                 Yes
*
         PUT   NEWDS                   Write R1 buffer and get new one
         ST    R1,RBUFF                Save start addr of buffer
*
         TM    TRECFM,X'40'            Variable records?
         BZ    FST010                  No
         LA    R1,4(,R1)               Leave space for RDW
*
FST010   EQU   *
         BCTR  R3,0                    Adjust for execute
         EX    R3,MVCSEG               Move segment data
         LA    R1,1(R3,R1)             -> next available byte
         ST    R1,RBPOS                Save record position
         B     PDATA000                Go get some more
*
FSTU100  EQU   *                    ** Here if RECFM=U only
         L     R1,NEWBLK               -> RECFM=U build buffer
         BCTR  R3,0                    Adjust for execute
         EX    R3,MVCSEG               Move segment data
         LA    R1,1(R3,R1)             -> next available byte
         ST    R1,RBPOS                Save record position
         B     PDATA000                Go get some more
*
*-- Last segment of a record
*
LST000   EQU   *                       Handle last segment
         L     R1,RBPOS                -> next available buffer byte
         LR    R0,R1                   Copy next available ptr     v222
         S     R0,RBUFF                Compute len used so far     v222
         AR    R0,R3                   Add len of next segment     v222
         CH    R0,NEWDS+(DCBLRECL-IHADCB) will segment fit in buff?v222
         BH    XITNET24                No. record too large        v222
         BCTR  R3,0                    Adjust for execute
         EX    R3,MVCSEG               Move segment data
         LA    R1,1(R3,R1)             -> next available byte
*
         TM    TRECFM,X'C0'            Using undefined format?
         BO    LSTU100                 Yes
*
         L     R3,RBUFF                -> record start
         TM    TRECFM,X'40'            Variable records?
         BZ    LST010                  No
*
         SR    R1,R3                   Compute record length
         LA    R0,CODE9                Assume bad segment length   v200
         CH    R1,NEWDS+(DCBLRECL-IHADCB) Chk RDW against LRECL    v200
         BH    XITNET08                It was                      v200
*
         SLL   R1,16                   Make RDW = LLZZ
         STCM  R1,15,0(R3)             Plug in RDW
         SRL   R1,16                   Make length
*
LST010   EQU   *
         B     PDATA000                Go get some more
*
LSTU100  EQU   *                    ** Here if RECFM=U only
         L     R2,NEWBLK               -> RECFM=U record build area
         SR    R1,R2                   Compute record length
         STH   R1,NEWDS+(DCBLRECL-IHADCB) Set len of output recrd
         LR    R3,R1                   Copy length to write
*
         PUT   NEWDS                   Write prv buffer and get new one
         LR    R0,R1                   -> PUT buffer to R0
         LR    R1,R3                   Length of record
         MVCL  R0,R2                   Move to PUT LOCATE buffer
         B     PDATA000                Go get some more
*
*-- Control record encountered in data stream
*
PDATA100 EQU   *
         SR    R0,R0                                                    NET00130
         IC    R0,0(,R1)               Get segment length byte          NET00140
         S     R0,=F'2'                Less 2 we already retrieved      NET00150
         LR    R3,R0                   Copy length of segment           NET00300
         BAL   R14,GETBYTES            Get a segment                    NET00160
*
         CLC   0(6,R1),INMR06          Is it INMR06?                    NET00330
         BNE   PDATA000                Ignore other control records
         B     XITNET00                Done
*
*-- Process FLAT FILE not in NETDATA format
*
*-- We've already read the first spool record, in REC.
*-- PUN files:  just write 80 byte records.
*-- PRT files:  write 133 bytes, always convert to ASA carriage ctl;
*--             the raw data over NJE is always M carriage ctl for PRT.
*
*-- Writing out to DCB NEWDS using MACRF=PL
*
*
*
PFLAT000 EQU   *
         LA    R6,TAGDATA
         USING TAG,R6
         LA    R4,X'40'                Assume CC of space 1
         B     PFLAT030                1st record is already in REC
*
*
*-- Retrieve the spool file records
*
PFLAT010 EQU   *
         BAL   R14,GET000              Get a record
         C     R15,=F'4'               EOF?
         BE    XITNET00                Yes, were done
         LTR   R15,R15                 Any errors?
         BNZ   XITNET16                Yes, deal with them
*
PFLAT030 EQU   *
         TM    TAGINDEV,TYPPUN         Is this punch data?
         BO    PFLAT180                Yes
*
*-- Output PRT records with RECFM=A carriage control
*
         TM    REC,X'03'               Immediate cmd CC in record?
         BNO   PFLAT070                No, this one is the data
*
         LA    R4,C'0'                 Space 2 lines
         CLI   REC,X'13'               Is CC character space 2 immed?
         BE    PFLAT010                Yes
         LA    R4,C'1'                 Skip to channel 1
         CLI   REC,X'8B'               Is CC character ch 1 immed?
         BE    PFLAT010                Yes
         LA    R4,C'-'                 Space 3 lines
         CLI   REC,X'1B'               Is CC character space 3 immed?
         BE    PFLAT010                Yes
         LA    R4,C'+'                 Suppress space
         CLI   REC,X'01'               Is CC character write sup imd?
         BE    PFLAT010                Yes
         LA    R4,X'40'                Otherwise use space 1
         B     PFLAT010
*
PFLAT070 EQU   *
         PUT   NEWDS                   Write a line
         LR    R5,R1                   Get new buffer addr
*
         STC   R4,0(,R5)               Set the CC byte
         LH    R1,NCB1+(NCBRECLN-NCB)  Get length of spool record
         BCTR  R1,0                    Less one to skip CC byte
         ICM   R1,8,BLANKS             Set pad char
         LA    R0,REC+1                -> spool input record skipping
*                                       the M carriage control
         LA    R14,1(,R5)              Where to build output record
         LH    R15,NEWDS+(DCBLRECL-IHADCB) get len of output recrd area
         BCTR  R15,0                   Less one to skip CC byte
         MVCL  R14,R0                  Move record and pad excess
         B     PFLAT010                Process another line
*
*-- PUN records
*
PFLAT180 EQU   *
         PUT   NEWDS                   Write a line
         LR    R5,R1                   Get new buffer addr
*
         LH    R1,NCB1+(NCBRECLN-NCB)  Get length of spool record
         ICM   R1,8,BLANKS             Set pad char
         LA    R0,REC                  -> spool input record
         LR    R14,R5                  Where to build output record
         LH    R15,NEWDS+(DCBLRECL-IHADCB) get len of output recrd area
         MVCL  R14,R0                  Move record and pad excess
         B     PFLAT010                Process another line
*
*
*                                                                       NET01580
*                                                                       NET01580
*                                                                       NET01580
*-- Request some more bytes of NETDATA formatted data                   NET01590
*                                                                       NET01590
*-- Entry:  R0 = # of bytes requested  (1-255)                          NET01590
*-- Exit:   R1 -> string of bytes obtained                              NET01590
*                                                                       NET01660
*-- Uses R0-R1,R5-R8,R14-R15; the caller's values in these              NET01660
*--      registers are not preserved across this call.
*                                                                       NET01660
GETBYTES EQU   *                                                        NET01670
         ST    R14,SV14GB              Save return addr                 NET01680
         L     R5,GBREM                Get # bytes remaining in rec buf NET01690
         LA    R1,BUFF                 Point to getbytes buffer         NET01700
         ST    R1,GBPOS                Set starting position            NET01710
*
         L     R8,GBRBA                Get RBA of current position
         ST    R8,GBPBA                Save prior RBA
         AR    R8,R0                   Compute next RBA
         ST    R8,GBRBA                Update RBA if successful
*
         LR    R8,R0                   Requested amount to R8           NET01720
*                                                                       NET01730
*                                                                       NET01740
GB010    EQU   *                                                        NET01750
         LTR   R5,R5                   Any bytes left in phy record?    NET01760
         BP    GB040                   Yes, use them first              NET01770
*                                                                       NET01780
         BAL   R14,GET000              Get a NETDATA record
         LTR   R15,R15                 Any errors?
         BNZ   GB090                   Yes, deal with them
*                                      R0-> length of record read       NET01850
         LR    R5,R0                   Num bytes read                   NET01840
         ST    R1,GBRPS                Reset start of record position   NET01880
*                                                                       NET01890
GB040    EQU   *                                                        NET01900
         LR    R7,R8                   Assume requested amt avail       NET01910
         LR    R15,R8                  Same                             NET01920
*                                                                       NET01930
         CR    R5,R8                   Have more than we need?          NET01940
         BH    GB050                   Yes, just move requested         NET01950
         LR    R7,R5                   Else move what we have           NET01960
         LR    R15,R5                  Same                             NET01970
*                                                                       NET01980
GB050    EQU   *                                                        NET01990
         LR    R0,R7                   Save copy of length to move      NET02000
         L     R14,GBPOS               -> GB buffer position            NET02010
         L     R6,GBRPS                -> input record curr position    NET02020
         MVCL  R14,R6                  Move                             NET02030
*                                                                       NET02040
         ST    R14,GBPOS               New GB position                  NET02050
         ST    R6,GBRPS                New phys record curr position    NET02060
*                                                                       NET02070
         SR    R5,R0                   Reduce bytes left in phy record  NET02080
         SR    R8,R0                   Reduce requested amt             NET02090
         BP    GB010                   We need more, go get it          NET02100
*                                                                       NET02110
         ST    R5,GBREM                Remember whats left in phy rec   NET02120
*                                                                       NET02130
         LA    R1,BUFF                 Point to the requested bytes     NET02140
         L     R14,SV14GB              Load  return addr                NET02150
         BR    R14                     Return from getbytes             NET02160
*                                                                       NET01980
GB090    EQU   *                                                        NET01990
         C     R15,=F'4'               End of file?
         BE    XITNET12                Yes
         B     XITNET16                I/O error
*
*-- Exit NETDATA processing
*
XITNET00 EQU   *
         SR    R15,R15             RC=0; NETDATA info filled
         B     XITNET
*
XITNET04 EQU   *
         LA    R15,4               RC=4; File doesnt lead off w/NETDATA
         B     XITNET
*
*-- Here if unexpected or unrecognized NETDATA sequences are found
*
*-- There are 8 places that could branch here; they are numbered 1-8
*-- in R0 to indicate how we arrived here "detection code".  Used
*-- with the input NETDATA record and byte number this code can
*-- help to locate the offending error.
*
*-- The detection CODEx equates below describe the 8 tests
*
CODE1    EQU   1                       Control record not indicated
CODE2    EQU   2                       INMR02 record not detected
CODE3    EQU   3                       Control record not indicated
CODE4    EQU   4                       INMR02 record not detected
CODE5    EQU   5                       INMR03 ctl rec not indicated
CODE6    EQU   6                       INMR03 record not detected
CODE7    EQU   7                       Inv/unrecognized NETDATA key
CODE8    EQU   8                       Ctl rec segment not detected
CODE9    EQU   9                       Incorrect segment lengths   v200
*
*-- Format error msg (MSG003):
*
*Invalid or unsupported NETDATA detected; error code x, record y byte z
*
*-- Note for debugging:  the record and byte number displayed point
*-- to the position in the original input at the point of the GETBYTES
*-- call.  The error may be at that exact byte or following it for
*-- some reasonable amount (up to 255 bytes).  For error codes 1-6 and
*-- code 8, the rec/byte shown is very close and usually exact. For
*-- code 7 errors there is an invalid or unknown text unit key and
*-- the invalid key is somewhere after the rec/byte shown in the
*-- next 255 bytes.
*
*-- For code 9, the record segment lengths exceeded the LRECL      v200
*--  (variable length records only).                               v200
*
XITNET08 EQU   *
         LR    R6,R0               Detection code to R6
*
         L     R1,GBPBA            Get RBA of prior GETBYTES call
         SR    R0,R0               Clear for divide
         D     R0,=F'80'           Compute input record number
         LA    R2,1                Load 1
         AR    R1,R2               Make record number relative to 1
         AR    R0,R2               Make byte number relative to 1
         CVD   R1,DBLE             Convert
         MVC   LIST(4+L'MSG003T),MSG003  Build msg
         MVC   TWRK(12),=X'402020206B2020206B202120' Edit mask
         LA    R1,TWRK+11          Start of significance
         EDMK  TWRK(12),DBLE+3     Edit record count
         LA    R2,TWRK+11          -> last digit of edited number
         SR    R2,R1               Compute display length
         EX    R2,MVREC            Move edited number to line
         LA    R1,LIST+67(R2)      -> next available byte in line
         MVC   0(8,R1),=C' byte xx'
*
         CVD   R0,DBLE             Convert byte position
         UNPK  6(2,R1),DBLE        Fill in byte #
         OI    7(R1),X'F0'         Fix sign
*
         STC   R6,LIST+56          Store detection code
         OI    LIST+56,X'F0'       Add a sign to make display
*
         LA    R1,8(,R1)           Compute end of msg text
         LA    R2,LIST             -> start of msg
         SR    R1,R2               Compute msg length RDW
         STH   R1,LIST             Set RDW
*
         BAL   R14,PUTLINE         Notify user
         LA    R15,8               RC=8; Invalid NETDATA detected
         B     XITNET
*
*-- EOF on NETDATA
XITNET12 EQU   *
         LA    R15,12              RC=12 unexpected EOF
         B     XITNET
*
*-- Read error on NETDATA
XITNET16 EQU   *
         LA    R15,16              RC=16 Read i/o error
         B     XITNET
*
*-- INMTERM text unit key detected and it is unsupported
XITNET20 EQU   *
         LA    R15,20              RC=20 INMTERM detected
         B     XITNET
*
*-- Segmented record pieces are too large for LRECL and exceed     v222
*--  the PUT record buffer                                         v222
XITNET24 EQU   *                                                   v222
         LA    R15,24              RC=24 record too large          v222
         B     XITNET                                              v222
*
XITNET   EQU   *
         L     R13,4(,R13)         -> prev s.a.
         ST    R15,16(,R13)        Set RC
         LM    R14,R12,12(R13)     Reload callers regs
         BR    R14                 Return with RC
*
MVREC    MVC   LIST+66(0),0(R1)    executed instr
*
         LTORG
*                                                                       NET02190
*                                                                       NET02190
*- Control records that we look for and process (others ignored).       NET02190
INMR01   DC    C'INMR01'               Header Control record            NET02200
INMR02   DC    C'INMR02'               File Utility Control record      NET02210
INMR03   DC    C'INMR03'               Data Control record              NET02210
INMR06   DC    C'INMR06'               Trailer Control record           NET02210
*                                                                       NET02220
*- Keys                                                                 NET02230
INMKEYS  DS    0H
INMBLKSZ DC    X'0030',AL4(BLK000)     Block size
INMCREAT DC    X'1022',AL4(CRE000)     Creation date
INMDDNAM DC    X'0001',AL4(DDN000)     DDNAME for the file
INMDIR   DC    X'000C',AL4(DIR000)     Number of directory blocks
INMDSNAM DC    X'0002',AL4(DSN000)     Name of the file
INMDSORG DC    X'003C',AL4(DSG000)     File organization
INMEATTR DC    X'8028',AL4(ATR000)     Extended attribute status
INMERRCD DC    X'1027',AL4(ECD000)     RECEIVE command error code
INMEXPDT DC    X'0022',AL4(EXP000)     Expiration date
INMFACK  DC    X'1026',AL4(0)  NO SPT--Originator requested notificat'n
INMFFM   DC    X'102D',AL4(FFM000)     Filemode number
INMFNODE DC    X'1011',AL4(FND000)     Origin node name or node number
INMFTIME DC    X'1024',AL4(FTM000)     Origin timestamp
INMFUID  DC    X'1012',AL4(FUS000)     Origin user ID
INMFVERS DC    X'1023',AL4(VER000)     Origin version num of the data
INMLCHG  DC    X'1021',AL4(LCH000)     Date last changed
INMLRECL DC    X'0042',AL4(LRL000)     Logical record length
INMLREF  DC    X'1020',AL4(LRF000)     Date last referenced
INMLSIZE DC    X'8018',AL4(LSZ000)     Data set size in megabytes.
INMMEMBR DC    X'0003',AL4(0)  NO SPT--Member name list
INMNUMF  DC    X'102F',AL4(NMF000)     Number of files transmitted
INMRECCT DC    X'102A',AL4(RCT000)     Transmitted record count
INMRECFM DC    X'0049',AL4(RFM000)     Record format
INMSECND DC    X'000B',AL4(SEC000)     Secondary space quantity
INMSIZE  DC    X'102C',AL4(FSZ000)     File size in bytes
INMTERM  DC    X'0028',AL4(TRM000)     Data transmitted as a message
INMTNODE DC    X'1001',AL4(TND000)     Target node name or node number
INMTTIME DC    X'1025',AL4(TTM000)     Destination timestamp
INMTUID  DC    X'1002',AL4(TUS000)     Target user ID
INMTYPE  DC    X'8012',AL4(TYP000)     Data set type
INMUSERP DC    X'1029',AL4(0)  NO SPT--User parameter string
INMUTILN DC    X'1028',AL4(UTL000)     Name of utility program
         DC    X'FFFF'                 End of table
KEYLEN   EQU   6                       Length of key/adcon pair
*
*-- Target fields from INMRxx control records that we recognize:
*
*-- Missing from the list and unsupported:
*--  INMFACK  1-64 bytes, notification string from transmit
*--  INMTERM  0 bytes, data was transmitted as a message
*--  INMUSERP 1-251 bytes, user PARM field string from TRANSMIT/RECEIVE
*
INMFIELD DSECT
UTLNAME  DS    0XL8,XL2,CL8           Utility name                      NET02490
FILESIZE DS    0XL8,XL2,XL8           File size in bytes                NET02500
DIRBLKS  DS    0XL8,XL2,XL8           #directory blocks                 NET02500
BLKSIZE  DS    0XL8,XL2,XL8           BLKSIZE                           NET02510
LRECL    DS    0XL8,XL2,XL8           LRECL                             NET02520
RECFM    DS    0XL2,XL2,XL2           RECFM                             NET02530
DSORG    DS    0XL2,XL2,XL2           DSORG                             NET02540
FFM      DS    0XL1,XL2,CL1           File mode number                  NET02550
DSNAME   DS    0XL44,XL2,CL44         DSNAME                            NET02580
FTIME    DS    0XL20,XL2,CL20         Origin time stamp                 NET02580
FNODE    DS    0XL8,XL2,CL8           Origin node                       NET02580
FUSER    DS    0XL8,XL2,CL8           Origin userid                     NET02580
TNODE    DS    0XL8,XL2,CL8           Dest node                         NET02580
TUSER    DS    0XL8,XL2,CL8           Dest userid                       NET02580
TTIME    DS    0XL16,XL2,CL16         Destination time stamp            NET02580
FVERS    DS    0XL8,XL2,XL8           Version                           NET02580
DDNAME   DS    0XL8,XL2,CL8           DDNAME                            NET02580
CREATE   DS    0XL16,XL2,CL16         Creation date                     NET02580
EATTR    DS    0XL1,XL2,CL1           Extended attributes               NET02550
ERRCD    DS    0XL1,XL2,CL1           Receive error code                NET02550
EXPDT    DS    0XL16,XL2,CL16         Expiration date                   NET02580
LCHG     DS    0XL16,XL2,CL16         Last Changed date                 NET02580
LREF     DS    0XL16,XL2,CL16         Last Referenced date              NET02580
LSIZE    DS    0XL4,XL2,XL4           Size of file in MB                NET02580
MEMBR    DS    0XL8,XL2,CL8           Member name list (1 supported)    NET02580
NUMF     DS    0XL8,XL2,XL8           Number of files in transmission   NET02520
RECCT    DS    0XL8,XL2,XL8           Number of records transmitted     NET02520
SECND    DS    0XL3,XL2,XL3           secondary space qty               NET02520
DSTYPE   DS    0XL1,XL2,XL1           Data set type                     NET02520
         DS    0H                     Force to halfword size
INMFSZ   EQU   *-INMFIELD             Size of DSECT
*
*                                                                       NJE00250
*********************
*  N J E P A R      *               NJEPAR calls IKJPARS to parse
*                   *               the TSO command line parameters.
*  TSO Command Line *
*  Parse            *
*                   *
*********************
*
*  Entry:  R0=0  Parse the command line parameters
*
*          R0=4  Parse the prompt parameters (change dsname, etc)
*          R1 -> Prompt input buffer from PUTGET if R0 = 4.
*
*  Exit:   R15 = IKJPARS RC
*
NJEPAR   CSECT
         B     28(,R15)               BRANCH AROUND EYECATCHERS
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJEPAR'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
*
         STM   R14,R12,12(R13)         Save Regs                        NJE00050
         LR    R12,R15                 Base                             NJE00060
         USING NJEPAR,R12                                               NJE00070
         USING NJEWK,R10
         ST    R13,PARSA+4             SAVE prv S.A. ADDR               NJE00080
         LA    R2,PARSA                -> my save area
         ST    R2,8(,R13)              Plug it into prior SA
         LR    R13,R2
*
*
         LR    R7,R0                   Copy entry action code
         LR    R6,R1                   Copy any passed ptr
*
         L     R1,CPARMS               -> CPPL entry parms
         LM    R2,R5,0(R1)             Get TSO command entry parameters
*                                       R2 -> Command buffer
*                                       R3 -> UPT
*                                       R4 -> PSCB
*                                       R5 -> ECT
*
*-- Build the IKJPARS PPL
*
PARS000  EQU   *
         LA    R8,PPLSTG               -> PPL
         USING PPL,R8
         ST    R3,PPLUPT               Set UPT addr
         ST    R5,PPLECT               Set ECT addr
         LA    R3,PARSECB              -> parse ECB
         ST    R3,PPLECB               Set it
         LA    R3,ANSWER               -> IKJPARS "answer area"
         ST    R3,PPLANS               Set it
         ST    R10,PPLUWA              Set user work area addr
         C     R7,=F'4'                Process prompt parameters?
         BE    PARS010                 Yes
*
*                                   ** Process command line
         ST    R2,PPLCBUF              Set TSO command buffer addr
         L     R3,=A(PCLDEFS)          -> command parms definitions
         ST    R3,PPLPCL               Set it
         B     PARS020
*
PARS010  EQU   *                    ** Process prompt parameters
         ST    R6,PPLCBUF              Set PUTGET input buffer addr
         L     R3,=A(PRMTOPS)          -> prompt parms definitions
         ST    R3,PPLPCL               Set it
*
PARS020  EQU   *
         CALLTSSR EP=IKJPARS,MF=(E,PPLSTG)   Parse command line
         LTR   R0,R15                  Any parse errors?
         BNZ   XITPAR12                Yes
         DROP  R8                      PPL
*
         C     R7,=F'4'                Did we parse prompt parms?
         BE    PARS200                 Yes, examine those
*
*- Examine command line results
         L     R4,ANSWER               -> IKJPARS built PCEs
         USING PRDSECT,R4
*
         LA    R2,FILEPCE              -> File #### PCE data
         TM    6(R2),X'80'             Was file #### specified?
         BZ    PARS025                 No
*
         L     R3,0(,R2)               -> word containing file #
         MVC   FILEID,0(R3)            Save specified spool id #
         OI    FLAGS3,F3FILEID         Indicate file id valid
*
PARS025  EQU   *
         LA    R2,QTPCE                -> QUIET PCE
         CLC   0(2,R2),=AL2(1)         Was QUIET specified?
         BNE   PARS030                 No
         OI    FLAGS3,F3QUIET+F3NPRMPT Indicate QUIET+NOPROMPT
*
PARS030  EQU   *
         LA    R2,PURPCE               -> PURGE/NOPURGE PCE
         CLC   0(2,R2),=AL2(2)         Was NOPURGE specified?
         BNE   PARS035                 No
         NI    FLAGS3,255-F3PURGE      Indicate no purge
*
PARS035  EQU   *
         LA    R2,PRMTPCE              -> PROMPT/NOPROMPT PCE
         CLC   0(2,R2),=AL2(2)         Was NOPROMPT specified?
         BNE   PARS040                 No
         OI    FLAGS3,F3NPRMPT         Indicate no prompts
*
PARS040  EQU   *
         LA    R2,VOLPCE               -> VOLSER PCE
         TM    6(R2),X'80'             Was VOLSER specified?
         BZ    PARS050                 No
         L     R3,0(,R2)               -> VOLSER string
         LH    R1,4(,R2)               Length of volser
         MVC   USRVOL,BLANKS           Init receiving field
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVVOL                Move the volser
         OI    FLAGS3,F3VOLSER         Indicate volser valid
*
PARS050  EQU   *
         LA    R2,INDAPCE              -> INDATASET PCE
         TM    6(R2),X'80'             Was INDATASET specified?
         BZ    PARS080                 No
         MVC   USRINDS,BLANKS          Init receiving field
         LA    R5,USRINDS              -> where to place DSN
*
         TM    6(R2),X'40'             Was dataset name in quotes?
         BO    PARS060                 Y, don't insert prefix
         CLC   PREFIX,BLANKS           Is a prefix available?
         BE    PARS060                 All blank, dont use prefix
*
         MVC   USRINDS(8),PREFIX       Add the prefix
         TRT   USRINDS,BLANK           Look for end of prefix
         MVI   0(R1),C'.'              Set delim after prefix
         LA    R5,1(,R1)               -> place to put rest of dsn
         LA    R2,INDAPCE              -> INDATASET PCE
*
PARS060  EQU   *
         L     R3,0(,R2)               -> INDATASET string
         LH    R1,4(,R2)               Length of DSN
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVINDS               Move the DSN
         OI    FLAGS3,F3INDS           Indicate INDATASET valid
*
PARS070  EQU   *
         TM    14(R2),X'80'            Was INDATASET member specified?
         BZ    PARS080                 No
         L     R3,8(,R2)               -> INDATASET member name
         LH    R1,12(,R2)              Length of member name
         MVC   USRMEM,BLANKS           Init receiving field
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVINMEM              Move the member name
         OI    FLAGS3,F3INMEM          Indicate INDATASET member valid
*
PARS080  EQU   *
         LA    R2,FDAPCE                -> DATASET PCE
         TM    6(R2),X'80'             Was DATASET specified?
         BZ    PARS110                 No
         MVC   FINALDS,BLANKS          Init receiving field
         LA    R5,FINALDS              -> where to place DSN
*
         TM    6(R2),X'40'             Was dataset name in quotes?
         BO    PARS090                 Y, don't insert prefix
         CLC   PREFIX,BLANKS           Is a prefix available?
         BE    PARS090                 All blank, dont use prefix
*
         MVC   FINALDS(8),PREFIX       Add the prefix
         TRT   FINALDS,BLANK           Look for end of prefix
         MVI   0(R1),C'.'              Set delim after prefix
         LA    R5,1(,R1)               -> place to put rest of dsn
         LA    R2,FDAPCE               -> DATASET PCE
*
PARS090  EQU   *
         L     R3,0(,R2)               -> DATASET string
         LH    R1,4(,R2)               Length of DSN
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVINDS               Move the DSN
         OI    FLAGS3,F3DS             Indicate DATASET valid
*
PARS100  EQU   *
         TM    14(R2),X'80'            Was DATASET member specified?
         BZ    PARS110                 No
         OI    FLAGS4,F4MEMINV         Indicate MEMBER specified
*
PARS110  EQU   *                                                   v200
         LA    R2,UNIPCE               -> UNIT PCE                 v200
         TM    6(R2),X'80'             Was UNIT specified?         v200
         BZ    PARS120                 No                          v200
         L     R3,0(,R2)               -> UNIT string              v200
         LH    R1,4(,R2)               Length of unit name         v200
         MVC   USRUNIT,BLANKS          Init receiving field        v200
         BCTR  R1,0                    Adjust for execute          v200
         EX    R1,MVUNIT               Move the unit               v200
         OI    FLAGS2,F2UNIT           Indicate unit valid         v200
*
PARS120  EQU   *                                                   v200
         LA    R2,DIRPCE               -> # dir blocks PCE         v200
         TM    6(R2),X'80'             Was DIR specified?          v200
         BZ    PARS130                 No                          v200
*
         L     R3,0(,R2)               -> word containing # blks   v200
         MVC   USRDIR,0(R3)            Save specified #            v200
         OI    FLAGS2,F2DIR            Indicate DIR valid          v200
*
PARS130  EQU   *                                                   v200
         B     XITPAR00                All done
         DROP  R4                      PRDSECT
*
MVVOL    MVC   USRVOL(0),0(R3)         executed instr
MVUNIT   MVC   USRUNIT(0),0(R3)        executed instr              v200
MVINDS   MVC   0(0,R5),0(R3)           executed instr
MVINMEM  MVC   USRMEM(0),0(R3)         executed instr
*
*
*- Examine prompt parameter results
PARS200  EQU   *
         L     R4,ANSWER               -> IKJPARS built PCEs
         USING PRMSECT,R4
*
PARS220  EQU   *
         LA    R2,ACTPCE               -> PURGE/END PCE
         CLC   0(2,R2),=AL2(1)         Was PURGE specified?
         BNE   PARS230                 No
         OI    FLAGS4,F4PURGE          Indicate purge
*
PARS230  EQU   *
         CLC   0(2,R2),=AL2(2)         Was END specified?
         BNE   PARS240                 No
         OI    FLAGS4,F4END            Indicate END
*
PARS240  EQU   *
         LA    R2,VLPCE                -> VOLSER PCE
         TM    6(R2),X'80'             Was VOLSER specified?
         BZ    PARS250                 No
         L     R3,0(,R2)               -> VOLSER string
         LH    R1,4(,R2)               Length of volser
         MVC   USRVOL,BLANKS           Init receiving field
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVVOL                Move the volser
         OI    FLAGS4,F4VOLSER         Indicate volser valid
*
PARS250  EQU   *
         LA    R2,DAPCE                -> DATASET PCE
         TM    6(R2),X'80'             Was DATASET specified?
         BZ    PARS280                 No
         MVC   FINALDS,BLANKS          Init receiving field
         LA    R5,FINALDS              -> where to place DSN
*
         TM    6(R2),X'40'             Was dataset name in quotes?
         BO    PARS260                 Y, don't insert prefix
         CLC   PREFIX,BLANKS           Is a prefix available?
         BE    PARS260                 All blank, dont use prefix
*
         MVC   FINALDS(8),PREFIX       Add the prefix
         TRT   FINALDS,BLANK           Look for end of prefix
         MVI   0(R1),C'.'              Set delim after prefix
         LA    R5,1(,R1)               -> place to put rest of dsn
         LA    R2,DAPCE                -> DATASET PCE
*
PARS260  EQU   *
         L     R3,0(,R2)               -> DATASET string
         LH    R1,4(,R2)               Length of DSN
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVINDS               Move the DSN
         OI    FLAGS4,F4DS             Indicate DATASET valid
         NI    FLAGS3,255-F3DS         DATASET from cmd line not valid
*
PARS270  EQU   *
         TM    14(R2),X'80'            Was DATASET member specified?
         BZ    PARS280                 No
         OI    FLAGS4,F4MEMINV         Indicate MEMBER specified
*
PARS280  EQU   *
         LA    R2,UNPCE                -> UNIT PCE                 v200
         TM    6(R2),X'80'             Was UNIT specified?         v200
         BZ    PARS290                 No                          v200
         L     R3,0(,R2)               -> UNIT string              v200
         LH    R1,4(,R2)               Length of unit name         v200
         MVC   USRUNIT,BLANKS          Init receiving field        v200
         BCTR  R1,0                    Adjust for execute          v200
         EX    R1,MVUNIT               Move the unit               v200
         OI    FLAGS2,F2UNIT           Indicate unit valid         v200
*
PARS290  EQU   *                                                   v200
         LA    R2,DRPCE                -> # dir blocks PCE         v200
         TM    6(R2),X'80'             Was DIR specified?          v200
         BZ    PARS300                 No                          v200
*
         L     R3,0(,R2)               -> word containing # blks   v200
         MVC   USRDIR,0(R3)            Save specified #            v200
         OI    FLAGS2,F2DIR            Indicate DIR valid          v200
*
PARS300  EQU   *                                                   v200
         B     XITPAR00                All done
         DROP  R4                      PRMSECT
*
*-- Exit
*
XITPAR00 EQU   *
         LA    R1,ANSWER               -> IKJPARS "answer place"
         IKJRLSA (1)                   Release parsing storage
*
         SR    R0,R0               Set secondary RC=0;
         SR    R15,R15             Set RC=0;
         B     XITPAR
*
XITPAR12 EQU   *
         LA    R15,12              Set RC=12; R0 already set by IKJPARS
         B     XITPAR
*
XITPAR   EQU   *
         L     R13,4(,R13)         -> prev s.a.
         L     R14,12(,R13)        Load r14
         LM    R1,R12,24(R13)      Reload callers regs
         BR    R14                 Return with RCs in R0/R15
*
         LTORG
*
*-- IKJPARS Description Macros
*
*-- RECEIVE command parms:
*
*     RECEIVE  #### INDATASET(ddd) VOLSER(vvv) UNIT(uuu) DATASET(iii)
*                   DIR(nnn)
*                   PURGE | NOPURGE
*                   PROMPT | NOPROMPT
*                   QUIET
*
*   Where:
*
*     #### if specified must be the first parm, all numeric spool id
*     ddd is an optional dataset name to RECEIVE from
*     vvv is an optional VOLSER of where to allocate the RECEIVEd data
*     uuu is an optional UNIT of where to allocate the RECEIVEd data
*     iii is an optional DSNAME to RECEIVE into.
*     nnn is an optional number of directory blocks to assign
*     PURGE indicates the spool file is purged after RECEIVE  (DEFAULT)
*     NOPURGE indicates the spool file is retained after RECEIVE
*     PROMPT indicates to prompt user for parameters          (DEFAULT)
*     NOPROMPT no user prompts are issued
*     QUIET  suppress all informational msgs
*
*
PCLDEFS  IKJPARM DSECT=PRDSECT
*
FILEPCE  IKJIDENT 'FILE NUMBER',                                       x
               MAXLNTH=4,FIRST=NUMERIC,OTHER=NUMERIC,                  x
               INTEG
*
PURPCE   IKJKEYWD DEFAULT='PURGE'
         IKJNAME  PURGE            PCE value = 1
         IKJNAME  NOPURGE          PCE value = 2
*
PRMTPCE  IKJKEYWD DEFAULT='PROMPT'
         IKJNAME  PROMPT           PCE value = 1
         IKJNAME  NOPROMPT         PCE value = 2
*
QTPCE    IKJKEYWD
         IKJNAME  QUIET            PCE value = 1
*
INDSPCE  IKJKEYWD
         IKJNAME  'INDATASET',SUBFLD=INDSFLD,ALIAS='INDSNAME'
*
FDSPCE   IKJKEYWD
         IKJNAME  'DATASET',SUBFLD=FDSFLD,ALIAS='DSNAME'
*
VSRPCE   IKJKEYWD
         IKJNAME  'VOLSER',SUBFLD=VOLSFLD,ALIAS='VOLUME'
*
USRPCE   IKJKEYWD ,                                                v200
         IKJNAME  'UNIT',SUBFLD=UNISFLD,ALIAS=('U')                v200
*
DRBPCE   IKJKEYWD ,                                                v200
         IKJNAME  'DIR',SUBFLD=DBSFLD                              v200
*
INDSFLD  IKJSUBF
INDAPCE  IKJPOSIT DSNAME,                                              x
               PROMPT='THE NAME OF THE DATA SET YOU WANT TO RECEIVE FROx
               M'
*
FDSFLD   IKJSUBF
FDAPCE   IKJPOSIT DSNAME,                                              x
               PROMPT='THE NAME OF THE DATA SET YOU WANT TO RECEIVE INTx
               O'
*
VOLSFLD  IKJSUBF
VOLPCE   IKJPOSIT DSTHING,VOLSER,                                      x
               PROMPT='THE VOLUME SERIAL OF THE VOLUME WHERE YOU WANT Tx
               HE DATASET ALLOCATED'
*
UNISFLD  IKJSUBF ,                                                 v200
UNIPCE   IKJIDENT 'UNIT NAME',MAXLNTH=8,FIRST=ALPHANUM,            v200x
               OTHER=ALPHANUM                                      v200
*
DBSFLD   IKJSUBF ,                                                 v200
DIRPCE   IKJIDENT 'DIRECTORY BLOCKS',                              v200x
               MAXLNTH=5,FIRST=NUMERIC,OTHER=NUMERIC,              v200x
               INTEG                                               v200
*
         IKJENDP
*
*-- RECEIVE parameters from prompt:
*
*     DATASET(ddd) VOLSER(vvv) UNIT(uuu) DIR(nnn) PURGE/END
*
*   Where:
*
*     ddd is an alternate dataset name to RECEIVE intp
*     vvv is an optional VOLSER of where to allocate the RECEIVEd data
*     uuu is an optional UNIT of where to allocate the RECEIVEd data
*     nnn is an optional number of directory blocks to assign
*     PURGE indicates the spool file is purged immediately and the
*      RECEIVE operation is aborted.
*     END indicates the RECEIVE operation is aborted with no action.
*
PRMTOPS  IKJPARM DSECT=PRMSECT
*
ACTPCE   IKJKEYWD DEFAULT=
         IKJNAME  PURGE            PCE value = 1
         IKJNAME  END              PCE value = 2
*
DSPCE    IKJKEYWD
         IKJNAME  'DATASET',SUBFLD=DAFLD,ALIAS='DSNAME'
*
VSPCE    IKJKEYWD
         IKJNAME  'VOLSER',SUBFLD=VLFLD,ALIAS='VOLUME'
*
USPCE    IKJKEYWD ,                                                v200
         IKJNAME  'UNIT',SUBFLD=UNFLD,ALIAS=('U')                  v200
*
DBPCE    IKJKEYWD ,                                                v200
         IKJNAME  'DIR',SUBFLD=DRFLD                               v200
*
DAFLD    IKJSUBF
DAPCE    IKJPOSIT DSNAME,                                              x
               PROMPT='THE NAME OF THE DATA SET YOU WANT TO RECEIVE INTx
               O'
*
VLFLD    IKJSUBF
VLPCE    IKJPOSIT DSTHING,VOLSER,                                      x
               PROMPT='THE VOLUME SERIAL OF THE VOLUME WHERE YOU WANT Tx
               HE DATASET ALLOCATED'
*
UNFLD    IKJSUBF ,                                                 v200
UNPCE    IKJIDENT 'UNIT NAME',MAXLNTH=8,FIRST=ALPHANUM,            v200x
               OTHER=ALPHANUM                                      v200
*
DRFLD    IKJSUBF ,                                                 v200
DRPCE    IKJIDENT 'DIRECTORY BLOCKS',                              v200x
               MAXLNTH=5,FIRST=NUMERIC,OTHER=NUMERIC,              v200x
               INTEG                                               v200
*
         IKJENDP
*
*
         IKJPPL
IKJPPLSZ EQU   (*-PPL)/4           # words in PPL
*
         LTORG
*
*                                                                     *
***********************************************************************
**                                                                   **
**                        TASK ESTAE EXIT                            **
**                                                                   **
** This csect handles all abends trapped by ESTAE during the normal  **
** execution of the subtask.          This exit does not attempt     **
** any recovery other than to terminate processing.                  **
** An SVC dump is taken on abends.                                   **
**                                                                   **
** On entry:  R0=ESTAE provide entry code                            **
**            R1=SDWA address                                        **
**            R2=parameter passed on ESTAE macro                     **
**                                                                   **
**                                                                   **
** On exit: If SDWACLUP is 1, then no retry is allowed and this      **
**             exit will allow percolation back to system routines   **
**             to terminate the task.                                **
**                                                                   **
**          If SDWACLUP is 0, then retry is allowed.                 **
**                                                                   **
** Security:  N/A.                                                   **
**                                                                   **
** Register usage:                                                   **
**                                                                   **
**   R1  = SDWA address                                              **
**   R3  = SDWA address                                              **
**   R10 = Dynamic storage area base                                 **
**   R12 = This program base                                         **
**                                                                   **
**                                                                   **
**                                                                   **
***********************************************************************
*
NJEDMP   CSECT
         B     28(,R15)               BRANCH AROUND EYECATCHERS
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJEDMP'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
*
         LR    R12,R15                SET UP BASE REG
         USING NJEDMP,R12             ESTABLISH ADDRESSABILITY
         LR    R8,R14                 SAVE RETURN ADDRESS TO SYSTEM
*
         L     R10,0(,R1)             GET VALUE PASSED TO US (WORKA)
         USING NJEWK,R10
         L     R11,=A(NJECOM)          -> common csect
         USING NJECOM,R11
*
         LR    R3,R1                  SAVE R1 ENTRY CONTENTS
         USING SDWA,R3
         LR    R5,R0                  Save R0 entry code
*
         LTR   R3,R3                  Do we have an SDWA?
         BZ    NOSDWA                 Exit if no SDWA
         LA    R13,MVSSAVE            Save area
         ESTAE 0
*
         MODESET MODE=SUP,            Run this ESTAI exit privileged   x
               KEY=ZERO                to access PSW -> storage
*
         MVC   MACLIST(WTOMSGL),WTOMSG
         L     R6,PSATOLD-PSA(0)      -> my TCB
         L     R5,TCBTIO-TCB(,R6)     -> TIOT
         MVC   MACLIST+9(8),0(R5)         Plug in job name
         MVC   MACLIST+4(4),=C'USER'
         MVC   MACLIST+19(7),=C'RECEIVE'  Plug in command name
*
*
LNK020   EQU   *
         MVC   MACLIST+29(5),=C'ABEND'
         L     R5,SDWAABCC              GET ABEND CODE INFO WORD
         N     R5,=X'00FFF000'          KEEP ONLY THE SYSTEM CODE
         BZ    USERCDE                  NONE THERE, MUST BE A USER CODE
         SRL   R5,12                    Put sys code in low order  v201
         C     R5,=X'00000222'          Operator cancel, no dump?  v201
         BE    SDUMP040                 Yes, suppress dump
         CLM   R5,1,=X'3E'              Was it an x3E (DETACH) ?   v201
         BE    SDUMP040                 Yes, suppress dump         v201
*
         MVI   MACLIST+35,C'S'          INDICATE SYSTEM CODE
         UNPK  FWORK(5),SDWACMPC(3)     GET SYSTEM CMP CODE
         TR    FWORK(3),HEXTRAN-240
         MVC   FWORK+3(5),=CL5' '       CLEAR REST OF ABEND CODE
         B     NOREAS
*
USERCDE  EQU   *
         MVI   MACLIST+35,C'U'         INDICATE USER ABEND CODE
         L     R5,SDWAABCC             GET ABEND CODE
         N     R5,=X'00000FFF'         KEEP USER ABEND CODE
         CVD   R5,FSAVE                CONVERT CODE TO DECIMAL
         UNPK  FWORK(4),FSAVE          UNPK THE CODE
         OI    FWORK+3,X'F0'           FIX SIGN
         MVC   FWORK+4(2),=CL2' '      BLANKS AT END OF ABEND CODE
*
NOREAS   EQU   *
         MVC   MACLIST+36(6),FWORK     MOVE ABEND-REASON TO LINE
         MVC   ABCODE,MACLIST+36       Save a copy of formatted abcode
*
         WTO   ,MF=(E,MACLIST)        Write to console
         LA    R2,MACLIST
         BAL   14,PUTLINE             Echo to TSO terminal
*
         MVC   MACLIST(WTOMSGL),WTOMSG
         MVC   MACLIST+4(3),=C'PSW'
         UNPK  FSAVE(9),SDWAEC1(5)    Add zones to PSW word 1
         TR    FSAVE(8),HEXTRAN-240
         MVC   MACLIST+10(8),FSAVE
         UNPK  FSAVE(9),SDWAEC1+4(5)  Add zones to PSW word 2
         TR    FSAVE(8),HEXTRAN-240
         MVC   MACLIST+19(8),FSAVE
*
         SR    R5,R5                   CLEAR FOR IC
         IC    R5,SDWAILC1             GET THE ILC
         CVD   R5,FWORK                MAKE DECIMAL
         MVC   MACLIST+29(3),=C'ILC'
         UNPK  MACLIST+33(2),FWORK     UNPK
         OI    MACLIST+34,X'F0'        FIX THE SIGN
*
         MVC   MACLIST+37(4),=C'INTC'
         UNPK  FWORK(5),SDWAINC1(3)    MAKE INTC DISPLAYABLE
         TR    FWORK(4),HEXTRAN-240
         MVC   MACLIST+42(4),FWORK     MOVE INTC TO LINE
*
         WTO   ,MF=(E,MACLIST)
         LA    R2,MACLIST
         BAL   14,PUTLINE             Echo to TSO terminal
*
         MVC   MACLIST(WTOMSGL),WTOMSG
         MVC   MACLIST+4(13),=C'DATA NEAR PSW'
         MVC   MACLIST+19(8),=CL8'UNAVAIL'  ASSUME WE CANT GET DATA
         L     R4,SDWAEC1+4            Get PSW IA
         LA    R4,0(,R4)               Clear high bit
         C     R4,=F'8'                1st 8 bytes of storage?
         BH    LOC010                  No, its higher than that
         SR    R4,R4                   Yes, just use 0
         B     LOC020
*
LOC010   EQU   *
         S     R4,=F'8'                BACK UP BEFORE INTERRUPT ADDR
*
LOC020   EQU   *
         LRA   R0,0(,R4)               Do we have access?
         BNZ   UNAVAIL                 No translation, better not
         LRA   R0,14(,R4)              Do we have access?
         BNZ   UNAVAIL                 No translation, better not
*
         ST    R4,FWORK                SAVE FOR CONVERSION
         UNPK  FSAVE(9),FWORK(5)       ADD ZONES TO ADDRESS
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   MACLIST+19(8),FSAVE     MOVE DISPLAYABLE
*
         MVC   FWORK(4),0(R4)          MOVE 4 WORDS AT PSW
         UNPK  FSAVE(9),FWORK(5)       ADD ZONES
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   MACLIST+29(8),FSAVE     MOVE TO LINE
*
         MVC   FWORK(4),4(R4)          MOVE 4 WORDS AT PSW
         UNPK  FSAVE(9),FWORK(5)       ADD ZONES
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   MACLIST+38(8),FSAVE     MOVE TO LINE
*
         MVC   FWORK(4),8(R4)          MOVE 4 WORDS AT PSW
         UNPK  FSAVE(9),FWORK(5)       ADD ZONES
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   MACLIST+47(8),FSAVE     MOVE TO LINE
*
         MVC   FWORK(4),12(R4)         MOVE 4 WORDS AT PSW
         UNPK  FSAVE(9),FWORK(5)       ADD ZONES
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   MACLIST+56(8),FSAVE     MOVE TO LINE
*
UNAVAIL  EQU   *
         WTO   ,MF=(E,MACLIST)
         LA    R2,MACLIST
         BAL   14,PUTLINE              Echo to TSO terminal
*----
         LA    R4,4                    4 ROWS OF REGISTERS
         LA    R5,SDWAGR00             POINT TO ABEND REGS
         LA    R6,REGLIST              POINT TO REGISTER ID LITERALS
*
REG000   EQU   *
         MVC   MACLIST(WTOMSGL),WTOMSG
         MVC   MACLIST+4(8),0(R6)      MOVE REGISTERS ID
         LA    R15,MACLIST+13          WHERE 1ST REG GOES ON LINE
         LA    R14,4                   4 REGS PER LINE
*
REG010   EQU   *
         UNPK  FSAVE(9),0(5,R5)        UNPK A REGISTER
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   0(8,R15),FSAVE          MOVE TO THE LINE
         LA    R15,10(,R15)            NEXT SPOT ON PRINT LINE
         LA    R5,4(,R5)               NEXT REGISTER
         BCT   R14,REG010              KEEP DOING REGS
         WTO   ,MF=(E,MACLIST)
         LA    R2,MACLIST
         BAL   14,PUTLINE              Echo to TSO terminal
         LA    R6,8(,R6)               NEXT REGISTER ID
         BCT   R4,REG000               GO DISPLAY THE NEXT ROW
*
*
SDUMP000 EQU   *
         L     R5,SDWAABCC             Get abend code info word
         N     R5,=X'00FFF000'         Keep only the system code
         SRL   R5,12                   Right justify the code
         C     R5,=X'00000222'         Operator cancel, no dump?
         BE    SDUMP040                Yes, skip dump
         CLM   R5,1,=X'37'             x37 abend code?
         BE    SDUMP040                Skip the dump
*
         MVI   DHDR,C' '
         MVC   DHDR+1(29),DHDR
         MVI   DHDR,29                IBM length of header
         L     R5,PSATOLD-PSA(0)      -> my TCB
         L     R5,TCBTIO-TCB(,R5)     -> TIOT
         MVC   DHDR+1(8),0(R5)        Use jobname in description
         MVC   DHDR+11(7),=C'RECEIVE' Use command name
         MVC   DHDR+21(7),ABCODE
*
         MVC   MACLIST(SDUMPL),SDUMP    MOVE SDUMP LIST TO WORK
         LA    R1,MACLIST
         SDUMP HDRAD=DHDR,              ISSUE SDUMP TO RECORD STATUS   x
               BUFFER=NO,                                              x
               QUIESCE=NO,                                             x
               SDATA=(RGN,CSA,LPA,SUM),                                x
               MF=(E,(1))
*
*
SDUMP040 EQU   *
*
SDUMP090 EQU   *
         LR    R1,R3                  SDWA BACK TO R1
         L     R15,=A(NJERCV)         Main csect addr
         ST    R15,SDWASRSV+4*R12     Plug it to R12
         L     R15,=A(EXIT08)         -> RECEIVE exit point
*
         SETRP RC=4,                  Retry - try to shut down RECEIVE x
               DUMP=NO,               Suppress any further dumps       x
               FRESDWA=YES,           Free the SDWA                    x
               RETREGS=YES,           Restore original regs            x
               RETADDR=(15)           Return to Receive exit point
*
NOSDWA   EQU   *                  **  NO RETRY AVAILABLE (OR DESIRED)
         SR    R15,R15                REQUEST PERCOLATION
         LR    R14,R8                 RESTORE RETURN ADDRESS
         BR    R14                    RETURN TO SYSTEM
*
         LTORG
*
SDUMP    SDUMP MF=L
SDUMPL   EQU   *-SDUMP
*
REGLIST  DC    CL8'GR 0-3'
         DC    CL8'GR 4-7'
         DC    CL8'GR 8-11'
         DC    CL8'GR 12-15'
*
WTOMSG   WTO   '                                                       x
                                             ',MF=L
WTOMSGL  EQU   *-WTOMSG
*
         LTORG
*
*
****  Main work area common                                             NJE00290
****  to all NJExxx CSECTs.                                             NJE00290
*                                                                       NJE00290
NJEWK    DSECT
NJEEYE   DS    CL4'NJER'           Eyecatcher
NJEWKLEN DS    F                   Getmain size of this area
*
DBLE     DS    D                   Work area                            NJE00310
TWRK     DS    2D                  Work area
LCLNODE  DS    CL8                 Local node id
DEFUSER  DS    CL8                 Default 'no security' userid
USERID   DS    CL8                 TSO Userid
PREFIX   DS    CL8                 TSO PREFIX
*
*
MACLIST  DS    CL96                   Macro expansion area
STAXLIST DS    CL20                   STAX parameter list
*                                                                       NET02360
CPARMS   DS    A                      -> input CPPL (entry parms)
PUTECB   DS    F                      ECB for PUTLINE/PUTGET
IOPLAREA DS    4A                     IOPL for PUTLINE/PUTGET
DEVINFO  DS    A                      -> Entry selected from disks tbl
SV14CTL  DS    A                      R14 save area                     NET02370
SV14GB   DS    A                      R14 save area                     NET02370
SV14GET  DS    A                      R14 save area                     NET02370
SV14LN   DS    A                      R14 save area                     NET02370
SV14PUR  DS    A                      R14 save area                     NET02370
SVR0CTL  DS    F                      R0 save of # value for a key      NET02370
*
GBREM    DS    F                      # bytes remaining in phys rec     NET02380
GBPOS    DS    A                      -> current position in BUFF       NET02390
GBRPS    DS    A                      -> current position in phys rec   NET02400
GBRBA    DS    F        for debug     RBA of last GETBYTES call         NET02400
GBPBA    DS    F        for debug     RBA of prior GETBYTES call        NET02400
RBUFF    DS    A                      -> Record build area
RBPOS    DS    A                      -> current position in RBUFF      NET02390
*
BLOCKLEN DS    F                      Length of block buffer
BLOCK    DS    A                      -> Block of physical records
NEWLEN   DS    F                      Length of NEWDS RECFM=U buffer
NEWBLK   DS    A                      -> NEWDS RECFM=U build buffer
*
OLD      DS    F                      For PUTGET, # segments
OLDMSGAD DS    A                      -> msg len/text
*
PARSECB  DS    F                      IKJPARS ECB
ANSWER   DS    F                      IKJPARS Answer area
PPLSTG   DS    (IKJPPLSZ)A            Space for PPL
FILEID   DS    F                      User specified spool id #
USRDIR   DS    F                      User specified # of dir blks v200
USRVOL   DS    CL6                    User specified VOLSER
USRUNIT  DS    CL8                    User specified UNIT name     v200
USRINDS  DS    CL44                   User specified INDATASET
USRMEM   DS    CL8                    User specified INDATASET member
FINALDS  DS    CL44                   Final dataset name
*
*
FLAGS1   DS    X                      Flag bits
F1INMR01 EQU   X'80'  1... ....        INMR01 fields processed
F1INMR2A EQU   X'40'  .1.. ....        1st INMR02 fields processed
F1INMR2B EQU   X'20'  ..1. ....        2nd INMR02 fields processed
F1INMR03 EQU   X'10'  ...1 ....        INMR03 fields processed
F1BATCH  EQU   X'08'  .... 1...        Running in BATCH TSO
F1ACEE   EQU   X'04'  .... .1..        Security is available on system
F1AUSR   EQU   X'02'  .... ..1.        Special user
F1APF    EQU   X'01'  .... ...1        Authorized at invocation
*
FLAGS2   DS    X                      Flag bits
F2NETOPN EQU   X'80'  1... ....        NETDATA DCB open
F2NCBOPN EQU   X'40'  .1.. ....        NETSPOOL NCB open
F2NEWOPN EQU   X'20'  ..1. ....        NEWDS DCB open
F2TERM   EQU   X'10'  ...1 ....        INMTERM text unit detected
F2DIR    EQU   X'08'  .... 1...        DIR (CMD -OR- PROMPT) spec. v200
F2FLAT   EQU   X'04'  .... .1..        Incoming file is a flat file
F2UNIT   EQU   X'02'  .... ..1.        UNIT (CMD -OR- PROMPT) spec.v200
F2FEND   EQU   X'01'  .... ...1        Force END in batch after 1st pmt
*                     .... ....        available bits
*
FLAGS3   DS    X                      Flag bits from CMD line parse
F3FILEID EQU   X'80'  1... ....        Spool file id specified
F3PURGE  EQU   X'40'  .1.. ....        1=PURGE, 0=NOPURGE
F3VOLSER EQU   X'20'  ..1. ....        VOLSER specified
F3INDS   EQU   X'10'  ...1 ....        INDATASET specified
F3INMEM  EQU   X'08'  .... 1...        INDATASET MEMBER specified
F3DS     EQU   X'04'  .... .1..        DATASET specified
F3NPRMPT EQU   X'02'  .... ..1.        NOPROMPT was specified
F3QUIET  EQU   X'01'  .... ...1        QUIET was specified
*
FLAGS4   DS    X                      Flag bits from prompt parse
F4MEMINV EQU   X'80'  1... ....        DATASET MEMBER specified (inval)
F4PURGE  EQU   X'40'  .1.. ....        PURGE (delete spool file & exit)
F4VOLSER EQU   X'20'  ..1. ....        VOLSER specified
F4DS     EQU   X'10'  ...1 ....        DATASET specified
F4END    EQU   X'08'  .... 1...        END (take no action and exit)
F4ATTN   EQU   X'01'  .... ...1        User pressed ATTN key       v201
*                     .... .xx.        available bits
*                                                                       NET02470
INMF01   DS    (INMFSZ)X              Fields from INMR01 record
INMF02A  DS    (INMFSZ)X              Fields from 1st INMR02 record
INMF02B  DS    (INMFSZ)X              Fields from 2nd INMR02 record
INMF03   DS    (INMFSZ)X              Fields from INMR03 record
*                                                                       NET02590
         DS    0F
BUFF     DS    CL256                  GB buffer containing request data NET02600
LIST     DS    CL133                  Print line                   v200
REC      DS    CL133                  Physical record from spool
*
*----
LS99PTR  DS    A                       PTR TO S99RB
LS99RB   DS    XL20                    SPACE FOR S99RB
*
TXTPTRS  DS    15A                     -> Text unit ptr list
*
         DS    0H
UTXT     DS    0XL06,Y,AL2,AL2         DDNAME Unallocation
UDDNAME  DS    CL8                      DDNAME
*
         DS    0H
TXT01    DS    0XL06,Y,AL2,AL2         Return DDNAME
TDDNAME  DS    CL8                      DDNAME
*
         DS    0H
TXT02    DS    0XL06,Y,AL2,AL2         DSN=
TDSNAME  DS    CL44                     DSNAME
*
         DS    0H
TXT03    DS    0XL07,Y,AL2,AL2,X       DISP=(NEW,
*
         DS    0H
TXT04    DS    0XL07,Y,AL2,AL2,X       DISP=(,CATLG)
*
         DS    0H
TXT05    DS    0XL06,Y,AL2,AL2         SPACE BLOCK LEN
TBLKLEN  DS    XL3                      BLKLEN
*
         DS    0H
TXT06    DS    0XL06,Y,AL2,AL2         SPACE PRIMARY
TPRIME   DS    XL3                      Primary
*
         DS    0H
TXT07    DS    0XL06,Y,AL2,AL2         SPACE SECONDARY
TSECND   DS    XL3                      Secondary
*
         DS    0H
TXT08    DS    0XL06,Y,AL2,AL2         SPACE DIRECTORY BLOCKS
TDIRBLKS DS    XL3                      DIR BLKS
*
         DS    0H
TXT09    DS    0XL06,Y,AL2,AL2         VOLUME
TVOLSER  DS    CL6                      VOLSER
*
         DS    0H
TXT10    DS    0XL14,Y,AL2,AL2         UNIT                        v200
TUNIT    DS    CL8                      UNITNAME                   v200
*
         DS    0H
TXT11    DS    0XL06,Y,AL2,AL2         EXPDT
TEXPDT   DS    CL5                      EXPDT=yyddd
*
         DS    0H
TXT12    DS    0XL06,Y,AL2,AL2         BLKSIZE
TBLKSIZE DS    XL2                      BLKSIZE
*
         DS    0H
TXT13    DS    0XL06,Y,AL2,AL2         DSORG
TDSORG   DS    XL2                      DSORG
*
         DS    0H
TXT14    DS    0XL06,Y,AL2,AL2         LRECL
TLRECL   DS    XL2                      LRECL
*
         DS    0H
TXT15    DS    0XL06,Y,AL2,AL2         RECFM
TRECFM   DS    XL1                      RECFM
*
         DS    0H
TXT16    DS    0XL04,Y,AL2             DUMMY
*
         DS    0H
TXT17    DS    0XL04,Y,AL2             SYSOUT
*
         DS    0H
TXT18    DS    0XL04,Y,AL2             TERM
*
         DS    0H
TXT19    DS    0XL04,Y,AL2             CYLINDER
*
         DS    0H
TXT20    DS    0XL04,Y,AL2             FREE=CLOSE
*---
*
CTL      DS    X                      Segment descriptor byte
*
*
         DS    0F
TAGDATA  DS    XL108                  TAG data area
TYPPRT   EQU   X'40'                   PRT dev
TYPPUN   EQU   X'80'                   PUN dev
*
NCB1     DS    XL48                   NCB for Spool Access
NETDATA  DS    (DMYNPSL)X             NETDATA DCB
NEWDS    DS    (DMYSEQL)X             New dataset DCB
DECB     DS    (READL)X               DECB for NETDATA
*
CPYPLIST DS    XL(COPYPRML)            IEBCOPY PARM FIELD
*
         DS    0H
DDLISTL  DS    AL2(DDLISTSZ)           DDNAME LIST LENGTH
DDLIST   DS    4XL8'00'                    FOUR DDNAMES UNDEFINED
DDSYSIN  DS    CL8    DDNAME representing IEBCOPY's SYSIN
DDSYSPR  DS    CL8    DDNAME representing IEBCOPY's SYSPRINT
         DS    XL8'00'                     UNDEFINED DD
DDSYSUT1 DS    CL8    DDNAME of ds created by INMRCOPY INMR02 (SYSUT1)
DDSYSUT2 DS    CL8    DDNAME representing IEBCOPY's SYSUT2
DDSYSUT3 DS    CL8    DDNAME representing IEBCOPY's SYSUT3
         DS    XL8'00'                     SYSUT4 UNUSED
DDLISTSZ EQU   *-DDLIST                LENGTH OF DDLIST for IEBCOPY
DDNETDAT DS    XL8'00'                 INDATASET DDNAME
DDNETSPL DS    XL8'00'                 NETSPOOL DDNAME
UNLISTSZ EQU   *-DDLIST                TOTAL of all DDs in list
*
*-- ESTAE exit used areas
*
FSAVE    DS    2D
FWORK    DS    D
DHDR     DS    CL30
ABCODE   DS    CL7
MVSSAVE  DS    18F                 ESTAE exit OS save
*-- End of ESTAE area
*
*
NJESA    DS    18F                    NJERCV OS save area               NJE00300
NETSA    DS    18F                    NJENET OS save area               NJE00300
DYNSA    DS    18F                    NJEDYN OS save area               NJE00300
PARSA    DS    18F                    NJEPAR OS save area               NJE00300
NOTSA    DS    18F                    NJENOT OS save area               NJE00300
*
         DS    0D                     Force doubleword size
NJEWKSZ  EQU   *-NJEWK
*                                                                       NJE00930
         CVT   DSECT=YES,PREFIX=NO
         IEFZB4D0
         IEFZB4D2
         DCBD  DSORG=PS,DEVD=DA
*
IEFUCBOB DSECT
         IEFUCBOB LIST=YES
         IHAPSA
         IKJTCB
         IHASDWA
IEFTIOT  DSECT
         IEFTIOT1
         IHAASCB
         IHAASXB
         IKJUPT
         IKJCPPL
         IKJPGPB
         IKJIOPL
*
ACEE     DSECT                         Maps a portion of ACEE in MVS3.8
ACEEEYE  DS    CL4'ACEE'
         DS    16X
ACEEUSRL DS    X                       Length of userid
ACEEUSR  DS    CL8                     Userid
*
         COPY  NETSPOOL                                                 NJE00940
         COPY  TAG
*
         END   NJERCV                                                   NJE01000
